#+title: 合理设计RESTful API
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+PANDOC_OPTIONS: css:'https://gist.githubusercontent.com/subchen/67816d94e6074002aab9/raw/3c510c007f70b5a534d44817e9f85c966fcdef42/github-markdown.css'


* 原则
图形界面作为面向用户的用户接口，一般都需要考虑用户体验。

API作为面向开发者的用户接口协议，同样需要精心的设计。

1. 简单、直观、统一。
2. 便于记忆，维护成本低。
3. 无歧义，预期稳定且唯一。
4. 高兼容性的协议，更容易适用更多的客户端形式。
5. 尽可能遵守业界公认标准或惯例，这么做后续平滑升级，新人培训都可低成本完成。
6. 查阅者体验优先。协议文档以网页形式共享，而不用Word, Excel等文件形式。

* 写在前面
API和数据库都是描述各种实体对象和它们属性。

但是从分层架构的视角看，数据库和API处在不同的分层中，职责也会有差别。

数据库是为服务端的业务层服务的，而API是服务客户端的。

API中有些信息可能直接从文件中读取，
或者来自内存缓存，消息队列，索引系统，其他子系统等等，
甚至有可能是组合构造全新的虚拟实体对象。

所以如果API协议中出现了数据库的表名、字段名，那也是“ *碰巧* ”，
而不是它本“应该”就那样。

你永远要努力向客户端屏蔽或隐藏它不需要知道的信息。

暴露的信息越多，升级或重构的时候你付出的代价就越大。

* 特殊信息
** 大数值字段 - 字符串
它之所以特殊，是因为很多数据库考虑到性能因素，ID字段都设置为数字类型。

比如：TINYINT, INT, BIGINT, unsigned BIGINT等。

但不同计算环境中，大数值数字的处理方式不一样。

特别是浏览器中，Javascript的Number类型是以64位的浮点数来标识的。

如果使用unsigned BIGINT，而刚好数值范围超出的浏览器能够处理的范围，
那么就有可能产生信息丢失或错误。

为了保险起见，这样的属性字段，在API中要使用字符串类型。

** 日期和时间 - ISO8601
日期和时间，因为涉及时区，涉及到Timestamp, GMT, UTC, CST等不同表达方式。

如果不统一，会产生很多问题。一律使用ISO8601格式的Datetime。

API中使用能够存储的最精确的时间，客户端使用时根据需要进行转换。

- 精确到秒: ~YYYY-MM-DDTHH:mm:ssZ~

  例如：2023-09-12T00:18:25Z

- 精确到毫秒: ~YYYY-MM-DDTHH:mm:ss.sssZ~

  例如：2023-09-12T00:18:25.532Z

- 精确到微秒: ~YYYY-MM-DDTHH:mm:ss.ssssssZ~

  例如：2023-09-12T00:18:25.513551Z

* ~基本实体~ 和 ~扩展实体~
RESTful API的后端，通常都是关系型数据库。

在关系型数据库的语境中，信息通常是 *范式化* 存储。

（见：[[https://en.wikipedia.org/wiki/Database_normalization][Database normalization）]]

基于这个背景，为了表述上的方便，定义两个概念。

后续的内容中如果有必要，可能会使用这两个概念。

注意观察 ~category~ 和 ~author~ 两个属性的区别。

** 基本实体
没有扩展关联对象的结构。
#+begin_example
{
    "id": "1234513432",
    "title": "合理设计RESTful API",
    "category": "14",
    "author": "23",
    "content": "..... ...... ......",
    "deleted": false,
    "ctime": "2024-08-23T21:43:21.234Z",
    "utime": "2025-03-15T12:07:59.234Z",
}
#+end_example

** 扩展实体
扩展了关联对象的结构。
#+begin_example
{
    "id": "1234513432",
    "title": "合理设计RESTful API",
    "category": {
        "id": "14",
        "pid": "7",
        "text": "规约设计",
        "deleted": false,
        "ctime": "2024-08-23T21:43:21.234Z",
        "utime": "2025-03-15T12:07:59.234Z",
    },
    "author": {
        "id": "1432414132",
        "nickname": "夏天的虫子",
        "username": "hanzhixing"
        "deleted": false,
        "ctime": "2024-08-23T21:43:21.234Z",
        "utime": "2025-03-15T12:07:59.234Z",
    },
    "content": "..... ...... ......",
    "deleted": false,
    "ctime": "2024-08-23T21:43:21.234Z",
    "utime": "2025-03-15T12:07:59.234Z",
}
#+end_example

* URI 和 URL
详见 [[https://en.wikipedia.org/wiki/Uniform_Resource_Identifier][Wikipedia URI]] 和 [[https://en.wikipedia.org/wiki/URL][Wikipedia URL]] 的说明。

#+begin_example
          userinfo       host      port
          ┌──┴───┐ ┌──────┴──────┐ ┌┴┐
  https://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top
  └─┬─┘   └─────────────┬────────────┘└───────┬───────┘ └────────────┬────────────┘ └┬┘
  scheme          authority                  path                  query           fragment
#+end_example

本文章中或多或少会直接使用这些术语。

* 命名风格
与计算机语言类似，RESTful风格的API协议中，我们也应该明确规定“标识符”的合法字符。

非常多的计算机语言中，由于考虑与 ~-~ 的冲突，
在变量名或者方法名等标识符中不允许出现 ~-~ 。

常见计算机语言中，标识符中可用的合法安全字符通常由 ~[A-Za-z0-9_]~ 构成。

从命名规范来看下面这几个用的最多。

- ~camelCase~
- ~PascalCase~
- ~snake_case~
- ~kebab-case~
- ~SCREAMING_SNAKE_CASE~

尽管API协议不受服务端或者客户端所使用的计算机语的约束，
但在不同语言中处理API协议中的标识符的时候，
通常需要较低成本就可以转换成自身语言中的标识符。
我们也经常使用自动映射工具来完成这种转换。
很多计算机语言都可以找到命名风格转换的工具。

所以，首先

#+begin_quote
计算机能够自动转换风格是 *底线* 。
#+end_quote

退而求其次，考虑到跨不同计算机语言的兼容性，我们应该

#+begin_quote
避免使用 ~kebab-case~ 。
#+end_quote

有很多计算机语言的标识符中不能包含 ~-~ 。

在一些不区分大小写的系统中 ~PascalCase~ , ~camelCase~
这种以大小写来确定词汇边界的命名方式，
极有可能变成 ~pascalcase~ , ~camelcase~ 。

如果我们把时间看得足够长，
我们就有机会在区分大小写的系统和不区分大小写的系统之间传播文件名等信息。
这大大增大了冲突或者被覆盖的概率。

大小写的差别消失之后，靠计算机来辨别原本存在的那些词汇边界会变得比较困难，
即便是人有的时候也需要花费精力才能辨别。

眼下业界被认同的惯例是（考虑到客户端的开发者体验、性能成本等因素）

#+begin_quote
尽量以符合客户端所使用的语言的命名规范来设计API协议
#+end_quote

但我们也要考虑服务端会由各式各样的使用不同语言实现的多种客户端进行消费。

这些语言之间，很大概率命名风格也不一样。

#+begin_quote
据统计 ~snake_case~ 风格比 ~camelCase~ 要容易阅读 *20%* 左右!
#+end_quote

所以综合考虑

#+begin_quote
应该优先使用 ~snake_case~ 。
#+end_quote

还有有些人可能没有注意到

#+begin_quote
在浏览器和绝大多数的软件中，
双击鼠标去选中标识符的时候， ~snake_case~ 一般能够完整的被选中，
复制比较方便。
#+end_quote

* Meta
#+begin_quote
计算机领域 *Meta* 通常指“ *描述数据的数据* ”或“ *关于数据的数据* ”。
#+end_quote

在RESTful风格的API协议设计中，
仅靠“实体”（例如“用户”）和“实体属性”（例如“用户”的“邮箱”），
是不足以表达我们需要的所有信息。

因此需要设置一些Meta变量来承载那些信息。

Meta信息的标识经常与“实体”和“实体属性”标识一起出现，
所以我们需要使用特殊字符防止它们和Meta信息的冲突。

计算机语言中使用比较多的有 ~$~ 和 ~_~ ，因为肉眼比较好识别。

但 ~$~ 上下匀称，更好看一些。

* Path
** 不使用动词，而是使用名词
RESTful风格的协议中，

用 *Http Method* 来回答： *做什么操作？*

- ~HEAD~: 探
- ~POST~: 增
- ~PATCH~: 改
- ~PUT~: 替
- ~GET~: 查
- ~DELETE~: 删

用 *URL* 来回答： *资源在哪里？*

#+begin_example
# Good!
/post/56/comment
/user/1341/post

# Evil!
/getPosts
/getUsers
/listPosts
/fetchAllComments
#+end_example

如果你执意把“ *做什么操作？* ”的信息放进URL中，
反而会给协议的使用者和维护者带来困惑。
#+begin_quote
到底在什么时候用get，什么时候用list，什么时候用fetch?
#+end_quote

** 使用单数，而不是复数
这一点可能会和你在网络上找到的RESTful最佳实践中的恰恰相反，
有不少文章是推荐使用复数。

例如：
- ~/posts~ 来表达“获取多个帖子”。
- ~/posts/123~ 来表达“在多个帖子中选择编号为123的那个帖子”。

如果用自然语言来理解，这样的确会更自然一些。

但是英语中有很多单复数不规则名词。

例如：
- ~people~ 既可以是“人”，也可以是“人民”。
- ~sheep~ 则单复数相同。
- ~axis~ 的复数既可以用 ~axes~ ，也可以用 ~axises~ 。
- ~criterion~ 的复数可以用 ~criteria~ 或 ~criterions~ 。

甚至，国内一些项目中也有 ~childs~ 当作 ~child~ 复数来使用的例子，
而 ~childs~ 实际为人名“蔡尔兹”。

笔者过去几年，也是复数的忠实粉丝，因为觉得复数更讲“人话”。

但是经历了几年的实践，经受了复数的各种摧残，再也不会纠结。

因为一定会使用“ *单数* ”。

我们在国内环境勉强可以自欺欺人地认为可以适当牺牲英语中精确的词法来换API表达的直观和易懂，但是如果团队是跨国团队怎么办？

所以，相比

#+begin_example
/:实体集合/:实体编号
#+end_example

我更推荐

#+begin_example
/:实体类型/:实体编号
#+end_example

这样的认知模型。

这么做我们至少可以让协议的使用者和协议的维护者统一预期，不再纠结。

API协议用在两个系统之间的“接口层”，"稳定的预期"带来的收益绝不可忽视。

很多时候,

#+begin_quote
唯一即简单。
#+end_quote

#+begin_quote
应竭尽全力消除任何形式的歧义。
#+end_quote

在每个高度聚合的团队内部的应用代码中，其实无所谓使用单数还是复数，甚至使用中文或者拼音都问题不大。
因为不管我们在API协议中不管使用单数还是复数，实际处理业务的程序代码中，我们在变量名、方法名等标识符的命名上，
从“可读性”角度出发，永远无法做到“只使用单数”或者“只使用复数”。

但是，

#+begin_quote
无论如何，我们都不应该把自身系统中不合理的设计或者小圈子内产生的妥协传播到他系统中去。
#+end_quote

#+begin_example
# Good!
/post/56/comment
/user/1341/post

# Bad!
/posts/56/comments
/users/1341/posts
#+end_example

** 不使用修饰词
如果没有这项限制，你很难阻止你的团队的成员在将来定义出
~postItems~ 、 ~postEntitis~ 、 ~commentObjects~ 等千奇百怪的命名，
最后导致合作的时候会花费大把的时间互相校对命名。

不要对资源实体对象进行修饰描述。

#+begin_example
# Good!
/user // 所有用户
/tag // 所有标签

# Evil!
/userList // List是废话
/tagItems // Items是废话
#+end_example

** 一致的模式
#+begin_example
/:实体类型/:实体编号/:实体类型/:实体编号...
#+end_example

下方URL都由相同的实体类型构成，但两个URL表达的含义是不一样的。
#+begin_example
# 从所有的标签中，找到编号为456的标签，并找到拥有该标签的所有帖子。
/tag/456/post

# 从所有的帖子中，找到编号为123的帖子，并检索该帖子的所有标签。
/post/123/tag
#+end_example

我们每天都在使用的域名其实也是这种方式组织信息的。

只不过域名是从后到前缩小领域，URL是从前到后缩小领域。

#+begin_quote
news.baidu.com. 所有商业类型网站中的，百度公司的，新闻频道。
#+end_quote

希望上面这个域名语义拆解，对你有帮助。

** ~$current~ , ~$all~
资源之间的关系比较复杂，查询的条件又不寻常的时候，我们遵守固定模式有些难度。
#+begin_example
/:实体类型/:实体编号/:实体类型/:实体编号...
#+end_example

我们约定 ~path~ 保持固定模式的好处是可以实现比较统一的 ~path~ 解析代码。

例如 ~/:type1/:type2/:id1~ 或 ~/:type1/:id1/:id2~ ，都是打破这样的约定。

我们可以引入 ~Path~ 中使用的 ~Meta~ 标识来解决这类问题。

见[[#特殊操作示例][特殊操作示例]]。

* Header
对于HTTP报文，Header本身即是Meta信息，例如:
~Authorization~, ~Content-Type~, ~User-Agent~ 等。

在HTTP协议中定义的标准Header之外，我们多少都需要自定义一些Header。

我们可以在[[https://www.iana.org/assignments/message-headers/message-headers.xml][IANA官方]]查看所有标准的HTTP头，
以及目前被列为提案并有可能成为标准的头。

[[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields][Wikipedia的List of HTTP header fields]]也是比较好的参考资料。

** 关于 ~X-~ 开头的Header
[[https://datatracker.ietf.org/doc/html/rfc6648][RFC6648]]中已明确废弃自定义Header以 ~X-~ 开头的推荐。

随着该RFC的普及，我们可以期待不会再产生似标准又非标准的 ~X-~ 开头的Header。

但是市面上已经有大量的软件使用了 ~X-~ ，它们成为了“事实上的标准”。

对于我们更重要的是，了解了这样的RFC产生的背景之后不再继续产生，
同时又要克制地使用这些Header。

建议任何RESTful API协议文档中，单独维护该类型的自定义Header列表。

本文档中使用的 ~X-~ 开头的Header如下。

** ~X-Total-Count~
在客户端需要展示总记录个数，总页数等场景下，需要知道记录的总数。

通过Response Header中的 ~X-Total-Count~ 字段返回该信息。

#+begin_example
X-Total-Count: 21
#+end_example

由于数据量很少，一次响应可以返回所有数据时，也可以通过“是否出现X-Total-Count字段”使客户端能够判断自己是否获取到所有数据。

** ~X-Request-Id~
客户端发起的每个请求的唯一标识，使用 [[./uuid-usage.org][UUID]] 。

在大型系统中可以用来关联不同子系统之间的日志，监控及排查故障时大有用途。

#+begin_example
X-Request-Id: 83fbbb94-ae84-4853-bf6c-613a12bfaf32
#+end_example

** ~X-RateLimit-Limit~
在一定的时间窗口内能够请求的最大次数。

#+begin_example
X-RateLimit-Limit: 100
#+end_example

** ~X-RateLimit-Remaining~
在一定的时间窗口内能够请求的剩余次数。

#+begin_example
X-RateLimit-Limit: 47
#+end_example

** ~X-RateLimit-Reset~
下一次重置频率限制数据的时间。

~UTC~ 时间以 ~UNIX timestamp~ 方式表达的值（秒）。

#+begin_example
X-RateLimit-Reset: 1742112652
#+end_example

** ~X-Csrf-Token~
见[[#csrf-cross-site-request-forgery][CSRF (Cross Site Request Forgery)]]。

** ~X-Http-Method-Override~
需要特殊实现，见[[#special-network][特殊网络环境]]。

* 状态码

| rfc        | 系列  | 含义       | 取值范围 | 个数 |
|------------+-------+------------+----------+------|
| [[https://datatracker.ietf.org/doc/html/rfc9110][RFC 9110]]   | ~1xx~ | 信息       |  100-101 | 2个  |
| （共41个） | ~2xx~ | 成功       |  200-206 | 7个  |
|            | ~3xx~ | 重定向     |  300-307 | 8个  |
|            | ~4xx~ | 客户端错误 |  400-417 | 18个 |
|            | ~5xx~ | 服务端错误 |  500-505 | 6个  |
|------------+-------+------------+----------+------|
| [[https://datatracker.ietf.org/doc/html/rfc6585][RFC 6585]]   | ~4xx~ | 客户端错误 |  428-431 | 3个  |
|            | ~5xx~ | 服务端错误 |      511 | 1个  |

如果计划遵守HTTP标准，最好不要使用 ~422~ 这种非 ~HTTP~ 协议规范中定义的状态吗。

在比较大的时间跨度上兼容性会得到最大保障。

使用标准化的状态码你至少会在以下几个方面收益。

#+begin_quote
1. 业界通用标准是成本最低的沟通手段。
2. 程序设计上更容易进行抽象和分治，通过 *AOP* 等设计模式可以让代码更简洁。
3. 反应真实情况的WEB服务日志，让你的监控和统计会变的更加轻松愉快。
#+end_quote

WEB服务器或框架会帮助我们处理一部分。

剩余的，我们也并不需要实现所有的。

也正因为只实现一部分，所以需要在协议文档中明确说明。

示例：

| Code | 默认返回文本        | 说明                         |
|------+---------------------+------------------------------|
|  200 | OK                  | 泛指成功。                   |
|  201 | Created             | 创建成功。                   |
|  202 | Accepted            | 成功接受请求。               |
|  204 | No Content          | 一般用在删除成功。           |
|  302 | Found               | 只用在需要自动重定向浏览器。 |
|  304 | Not Modified        | 一般配合浏览器缓存使用。     |
|  307 | Temporary Redirect  | 告知客户端地址临时改变。     |
|  400 | Bad Request         | 泛指的客户端错误，见[[#异常][异常]]。   |
|  401 | Unauthorized        | 身份验证未通过。             |
|  403 | Forbidden           | 权限验证未通过。             |
|  404 | Not found           | 请求的资源不存在。           |
|  409 | Conflict            | 资源冲突。                   |
|  429 | Too Many Requests   | 限制频率时用。               |
|  501 | Not Implemented     | 尚未实现。                   |
|  503 | Service Unavailable | 因维护不可用。               |

#+begin_quote
不要以其他状态码返回 ~5XX~ 的服务端异常！
#+end_quote

由于客户端作为信息的构造和提交的一方，自然掌握着请求的所有“知识”。

当发生客户端异常的时候，客户端可以根据服务端的 ~4XX~ 响应，
来“修正”这类异常，使得用户从这样的“错误”得到“解救”。

这才是 ~4XX~ 状态码的意义所在。

从软件设计的角度，客户端代码中不应该包含大量应付服务端实现细节的内容。

从安全性的角度，
- 客户端也不应该掌握着关于服务端的架构方案的知识。
- 客户端也不应该具备探测服务端背后信息链路细节的能力。

客户端是否向终端用户实现友好的 ~5XX~ 的反馈内容，
也不应该成为服务端是否可以返回 ~5XX~ 异常的决策依据。

网络、CPU、内存、磁盘天然哪个都有可能成为瓶颈和故障点。

实事求是地响应 ~5XX~ ，实事求是地记录日志，在前期查缺补漏、完善监控，
找到并加固整体系统的脆弱点有很重要的意义。

* 异常
** 401 - 身份验证未通过
#+begin_example
Status Code: 401 Unauthorized
#+end_example

很多年前以网站多以服务端渲染为主，当Cookie或Session建立的会话失效时，会通过3XX响应重定向浏览器访问登录界面。

如今，越来越多的Web应用使用异步请求完成登录的操作，不再依赖服务端来完成此类重定向。

因为Javascript没有权限读取 ~3XX~ 响应中的 ~Location~ ，
所以浏览器应用也无法使浏览器访问（浏览器地址栏变成）
~Location~ 头中指定的地址。

同时，现代的Web前端应用多数都会使用前端路由，而不是服务端路由。

这意味着服务端不再需要，从分工和职责边界的角度来看，
也不应掌握关于前端路由表相关的设计细节。

（前端路由表指的是浏览器地址栏中出现的地址的路由表，并非API地址的路由表）

在变更比较频繁的应用中，更是如此。

从服务端开发者的角度，
始终及时维护时刻变化但自身又完全用不着的前端路由信息非常不合理。

从浏览器端开发者的角度，每次变更路由信息，
都需要带上服务端的开发人员一起修改代码，也会大大降低开发效率。

因此，在使用的前端路由技术的Web应用中，如果条件允许，
应尽可能把身份验证未通过时的 ~3XX~ 重定向的实现修改为 ~401~ 的响应。

如果创建会话（登陆）的API的地址为动态的，
或者不希望前端应用代码中硬编码该地址，可以使用 ~Location~ 返回该地址。

#+begin_example
Status Code: 401 Unauthorized
Location: /login
#+end_example

** 403 - 权限验证未通过
#+begin_example
Status Code: 401 Unauthorized
#+end_example

- ~Authorize~ 一般指对特定的资源授予权限的行为。
- ~Authenticate~ 一般指授予特定身份的行为。

在一个系统中拥有某一种身份，不等同于对该系统中任何资源都有访问权限。

这像你是学生可以进入学校，可以进入教室，但是你不能到校长办公室自习。

相比 ~401~ 表示“身份验证”未通过，
~403~ 的响应表示“ *身份验证* ”可能通过并且服务端也能够识别请求，
但是因为 *权限不足* 拒绝客户端获取资源。

** 404 - 资源不存在
#+begin_example
Status Code: 404 Not Found
#+end_example

** 409 - 资源冲突
#+begin_example
Status Code: 409 Conflict
#+end_example

~PUT~ 原本用来完成“替换”的操作，
但也有不少应用会用 ~PUT~ 来创建路径事先确定的对象
（例如图片、视频、压缩文件等）， 这时如果资源已被创建，
就会用 ~409~ 响应客户端，表示资源已存在无法覆盖。

除此之外，实体数据的多个字段构成“ *唯一键* ”的情况下，
~POST~ 来创建新对象也有可能产生冲突，此时也可以使用 ~409~ 。

~409~ 响应时，
一般是比较明确客户端可以通过变更部分请求内容重新请求来“ *修复* ”这样的冲突。

如果客户端仅靠 ~409~ 状态码来修正冲突，推荐使用 ~400~ 来响应，
并且通过 ~Body~ 告知客户端冲突的原因或细节。

** 429 - 频率限制
服务端实现频率限制策略的情况下，由于客户端的忽视导致的异常应该使用该状态码。

#+begin_example
Status Code: 429 Too Many Requests
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Rest: 1742112652
Retry-After: 120
#+end_example

** 400 - 其他客户端异常
凡是需要具体内容才能够描述清楚的客户端异常应该都使用 ~400~ 响应，
并且 ~Body~ 按照如下格式。
#+begin_example
{
    # 可枚举的错误码，类型和值均可以通过协商定义
    "code": "E611",
    "msg": "Form fields vailidation is failed.",
    # 可选。描述出现异常的具体字段。
    "field": [
        {
            # 字段路径的keypath，用数组表示
            "key": ["password"],
            "msg": "Password is too short."
        },
        {
            "key": ["mobile"],
            "msg": "The phone number you entered is not valid."
        }
        {
            # contact对象的email属性
            "key": ["contact", "email"],
            "msg": "Email address can not be longger than {length} characters.",
            # 可选。通过这种方式可以与国际化方案结合。
            # 此时msg为msgid，客户端与服务端共享该msgid信息。(Gnu Gettext)
            "vars": {
                length: 100,
            }
        },
        # 相同的key出现多个异常时，采用平铺方式而不是嵌套数组方式。
        {
            "key": ["contact", "email"],
            "msg": "Email address can only contain {allowed}.",
            "vars": {
                allowed: "letters (a-z), numbers (0-9), and periods (.), and @",
            }
        },
        {
            # 可以推断提交的Body是数组
            # 表示第2个对象address对象的city属性有异常
            "key": [2, "address", "city"],
            "msg": "The City of an Address can not be empty."
        }
    ]
}
#+end_example

* Query
** URL Encode
严格来讲应该按照[[https://datatracker.ietf.org/doc/html/rfc3986][RFC 3986]]进行编码，具体规则可以参考[[https://en.wikipedia.org/wiki/Percent-encoding][URL Encode]]。

但如果你记不住可以按照下面规则。

#+begin_quote
*值* 中如果出现英文字母和数字以外的其他字符，一律需要 ~URL Encode~ 。
#+end_quote

大多数Web框架都可以自动解码。

当前文章中，为了演示目的，不会一一进行 ~URL Encode~ 。

** 数组
*** 使用 ~repeat~ 模式
#+begin_example
/user?age=21&age=23&age=25
#+end_example

重复使用相同的字段指定不同的值来表示数组。

#+begin_quote
Why?
#+end_quote

该表达形式虽然不是最精炼的，但实际实践中问题较最少。

使用遵守[[https://datatracker.ietf.org/doc/html/rfc6570][URI Template - rfc6570]]的工具编码解码时完美兼容。

其他理由见以下几例 *不使用* 格式。

*** 不使用 ~application/x-www-form-urlencoded~

#+begin_example
/user?age[]=21&age[]=23&age[]=25
#+end_example

#+begin_quote
Why?
#+end_quote

现代主流浏览器端流行框架的解决方案中几乎全面放弃默认以该格式提交数据，
而是建议让开发者使用 ~application/json~ 。

遵守 ~OpenAPI~ 标准的 ~Swagger~ 中也不支持该格式，见[[https://swagger.io/specification/#parameter-object][Parameter Object]]一节。

如果你希望团队的API协议通过Swagger等工具变成在线可查的文档，
那坚决不要使用该格式。

*** 不使用 ~comma~ 模式
#+begin_example
/user?age=21,23,25
#+end_example

#+begin_quote
Why?
#+end_quote

值部分可能会出现包含 ~,~ 逗号或 ~&~ 与号的内容。

虽然这部分可以通过 ~URL Encode~ 解决，但事情并没有那么简单。

包括 ~Spring~ 在内的诸多服务端Web框架为了开发者便利会自动
~URL Decode~ ，服务端工程师会获取到有别于客户端意图的数据。

除非客户端和服务端工程师通过协商两次 ~URL Encode~ 来规避这个问题，
但两次 ~URL Encode~ 在双方都会增加额外成本。

因为它们都需要特殊对待。

** 过滤 - 比较运算符
| 符号 | 含义                 |
|------+----------------------|
| ~=~  | 等于                 |
| ~!=~ | 不等于               |
| ~>=~ | 大于等于             |
| ~<=~ | 小于等于             |
| ~%=~ | 模糊匹配（前缀匹配） |

#+begin_example
GET /user?age>=25&age<=31&job!=writer&sex=male&name%=Mike
#+end_example

#+begin_quote
为什么没有“ *大于，小于，前后模糊* ”等？
#+end_quote

网络上也确实能够找到利用例如 ~eq~, ~ne~, ~lt~, ~le~, ~gt~, ~ge~
等保留字来描述“ *等于、不等于、小于、小于等于、大于、大于等于* ”的方案。

其实希望通过 ~query~ 参数构造这般复杂的查询条件时，
你的查询条件很有可能变得进一步复杂。

以上列举的仅仅是比较运算符，除了这些，
或许你还需要定义逻辑运算符或如 ~in~ 等关系运算符。

当问题域的确扩展到这个地步的时候，相比在 ~query~ 参数上做文章，
实现适用于 ~query~ 的 ~DSL~ 可能更佳划算。

但上升到 ~DSL~ ，我们就需要考虑它的完备性，甚至它有可能需要等价于 ~SQL~ 。
定义是一方面，还需要解决解析层面的实现以及使用成本。

如果你天真地相信其他工程师愿意学习和使用半成品的 ~DSL~ ，
那么你极有可能低估了其他“ *工程师的洁癖和对通用标准的向往* ”。

#+begin_quote
在实际软件工程实践中，我们永远在利用有限的资源，去解决有限的问题，而不是不计代价地去解决所有的假想问题。
#+end_quote

如果你仍然纠结上方表格中“ *只有大于等于，没有大于* ”的问题，
不妨试着用以下方法多定义几个 ~Meta~ 字段。

#+begin_example
?[ `$eq` | `$ne`| `$lt` | `$le` | `$gt` | `$ge` ].{field}={value}&...
#+end_example

例如
#+begin_example
GET /user?$gt.age=21&$ne.age=25&$lt.age<=31&$ne.job=writer&sex=male
#+end_example

** 排序 - ~$sort~
| 参数    | 值                                                         |
|---------+------------------------------------------------------------|
| ~$sort~ | 英文 ~,~ 分割，默认正序，英文 ~-~ 倒序。顺序影响排序结果。 |

#+begin_example
GET /user?$sort=-age,sex,-job
#+end_example

** 搜索 - ~$keyword~
有一些检索场景是没有办法明确指定具体字段，甚至是实体资源类型。

例如，检索标题、摘要或者内容中包含某种关键词的所有帖子的场景。
（无法事先知道匹配哪个字段）

#+begin_example
GET /post?$keyword=网络防火墙
#+end_example

再比如，检索包含某种关键词的所有多媒体（图像、音频、视频等）。
（无法事先知道匹配哪个类型的实体）

#+begin_example
GET /media?$keyword=加菲猫
#+end_example

由于关键词也有可能包含特殊符号，
因此希望支持数组时最好也使用[[#数组][数组]]一节中的规则。

#+begin_example
GET /media?$keyword=加菲猫&$keyword=拉布拉多
#+end_example

正常来讲，这种场景一般是在服务端搜索引擎方案下完成分词和检索操作。

** 分页 - ~$page~ 和 ~$count~ （推荐）
| 参数     | 值     | 含义                   | 默认值   |
|----------+--------+------------------------+----------|
| ~$page~  | 正整数 | 页码                   | 1        |
| ~$count~ | 正整数 | 单次可查询的最大记录数 | 协商确定 |

客户端未给定 ~$page~ 参数时，服务端按照默认值处理（必须）。

也可与客户端协商 ~$page~ 不可为空，如果为空以 ~400~ 的异常响应请求（可选）。

不管客户端是否给定 ~$count~ ，服务端无论如何都要设定合理的默认值（必须）。

~$count~ 的取值过大，会导致服务端处理的单个请求时内存占用过大，
即使服务端能够处理，网络传输也有可能成为瓶颈点，或客户端无法处理。

服务端从技术实现上，也不应该假设所有客户端都是“ *合法的* ”客户端。

对于“合法的”客户端而言，一旦服务端确定下来该最大值，
它就可以根据实际情况在不超过最大值的前提下灵活改变 ~$count~ 的取值。

目前由用户自己指定每页记录数的用户界面实现也比较常见。

出现该请求参数的组合时，服务端通常需要同时返回 ~X-Total-Count~ 。

** 分页 - ~$offset~ 和 ~$limit~
| 参数      | 值              | 含义                   | 默认值   |
|-----------+-----------------+------------------------+----------|
| ~$offset~ | 大于等于0的整数 | 偏移量。               | 0        |
| ~$limit~  | 正整数          | 单次可查询的最大记录数 | 协商确定 |

该组合与 ~$page~ 和 ~$count~ 的组合完全等价，可相互无损转换。

区别只是相比 ~$page~ 和 ~$count~ ，没那么讲“人话”，但更偏向数据库的原始语义。

同样，需要同时返回 ~X-Total-Count~ 。

** 分页 - ~$cursor~ 和 ~$count~
| 参数                           | 值     | 含义                               | 默认值           |
|--------------------------------+--------+------------------------------------+------------------|
| ~$cursor~ 或 ~$cursor.{field}~ | 正整数 | 上一个集合中，最后一个记录的唯一键 | 无该参数，或为空 |
| ~$count~ 或 ~$limit~           | 正整数 | 单次可查询的最大记录数             | 协商确定         |

在数据量过大的系统中，
服务端极有可能无法根据请求中的查询条件向客户端返回 ~X-Total-Count~ 。

通常在使用关系型数据库的情况下，由于排序和获取子集的计算是数据库系统中完成。

~X-Total-Count~ 的信息是需要多查询一次数据库才能获取到，
并且是性能损耗非常大的操作。

这一看似简单的操作，在数据规模超过一定量级之后，
从性能损耗和查询时长的角度来看，会变得不可能。

这样数据规模的系统，如果同时还具有数据更新非常活跃的特征。

“ *某种特征的数据集合的精确总数* ”有可能是上百万、上千万，
甚至，上亿为基础的数据以每秒数万、数十万个的速率发生变化的数值。

我们哪怕能够通过技术手段做到符合某种特征的数据集合没那么实时精确，
把不同特征组合数及相应的技术成本放在一起考虑的的时候，
也很快会发现这样做明显是投入产出不成比例的亏本买卖。

在超过一定数量级之后，实时精确的“ *总数* ”，
对用户也没有小数量级时那么有参考价值。

为了方便理解，在这里使用少量模拟的数据进行说明。

~$cursor~ 表示第二次查询的游标位置。

| ~$cursor.id~ |  Id | Name     | Age | Sex |
|--------------+-----+----------+-----+-----|
|              |  35 | XiaoMing |  36 | M   |
|              |  23 | ZhangSan |  33 | M   |
|              |   5 | LiSi     |  31 | M   |
|              |  27 | SunQi    |  31 | F   |
| -->          |  67 | ZhaoLiu  |  29 | M   |
|              |  17 | MeiMei   |  26 | F   |
|              |  29 | ZhengShi |  24 | M   |
|              |  31 | ZhouBa   |  24 | F   |
|              |  19 | WangWu   |  22 | F   |
|              |  41 | MeiMei   |  19 | F   |
| ...          | ... | ...      | ... | ... |

假设客户端为了获取以上集合，第一次查询通过如下参数请求，获取前5个。
#+begin_example
# 年龄倒序，性别正序（M-F），最多一次取5个。
# 该请求查询Id为35, 23, 5, 27, 67的记录。
/person?$sort=-age&$sort=sex&$count=5
#+end_example

客户端在首次查询之后，由于尚未获得游标之后记录的信息，
也就是Id为17的记录以及之后的记录，
因此无法告知服务端下一次查询应该从Id为17的记录开始查询，
只能告知服务端相同查询条件下，上一次查询游标截止的位置。

那么，第二次请求中客户端通过如下参数获得后续的数据集。
#+begin_example
/person?$sort=-age&$sort=sex&$count=5$cursor.id=67
#+end_example

这时，服务端根据排序规则和游标信息，可查询第二次查询对应的5条记录。

#+begin_src sql
SELECT t.*, c.*
FROM person t 
CROSS JOIN (SELECT * FROM person WHERE id = 67) c
WHERE (
    t.age < c.age
) OR (
    t.age = c.age AND t.sex < c.sex
) OR (
    t.age = c.age AND t.sex = t.sex AND t.id <= c.id
)
ORDER BY t.age DESC, t.sex DESC, t.id DESC
LIMIT 1, 5
#+end_src

如果数据集可以提供唯一ID，可以不为 ~$cursor~ 指定字段名。

#+begin_example
/person?$sort=-age&$sort=sex&$count=5$cursor=67
#+end_example

当数据集并不包含唯一ID字段时，
我们不得不使用多个字段的组合来确定记录的“ *唯一键* ”，
这时我们无论如何都要向服务端提供构成“唯一键”的字段信息。

例如
#+begin_example
/person?$sort=-age&$sort=sex&$count=5$cursor.age=29&$cursor.sex=M&$cursor.name=ZhaoLiu
#+end_example

当然，这种情况下数据库查询语句也需要相应地进行修改。

所以，比较推荐 ~$cursor~ 始终以 ~$cursor.{字段名}~ 格式传递信息，保持一致性。

除此之外，在这种场景下，客户端如果有用户界面，
那么它的分页查询的形式很有可能是点击“加载更多”按钮，或者滚动加载的形式。

这时，尽管客户端不再需要精确的 ~X-Total-Count~ 的信息，
但仍然需要知道“是否有更多”。

虽然我们也可以允许例如 ~X-Has-More~ 这样的自定义头，
但尽最大努力不增加非标准的自定义头的原则的角度，
我们完全可以利用 ~X-Total-Count~ 头来达到相同的效果。

因为客户端只是想知道“ *是否有更多* ”，所以服务端和客户端完全可以协商，
一旦有更多数据就保证响应头中的 ~X-Total-Count~ 大于0（例如1）
或者大于 ~$count~ 值（例如 ~$count + 1~ ）来表达 ~X-Has-More~ 的含义。

** 属性挑选 - ~$pick~
只挑选部分属性，不允许与 ~$omit~ 同时出现。

#+begin_example
# 只挑选姓名、年龄、性别等3个属性
/person?$pick=name&$pick=age&$pick=sex
#+end_example

** 属性排除 - ~$omit~
排除部分属性，不允许与 ~$pick~ 同时出现。

#+begin_example
# 排除内容，创建时间2个属性
/post?$omit=content&$omit=ctime
#+end_example

** 属性扩展 - 内嵌 - ~$embed~
见[[#基本实体-和-扩展实体][基本实体和扩展实体]]，内嵌关联对象。

#+begin_example
# 内嵌地址对象
/person?$embed=address

# 内嵌用户对象
/post?$embed=author
#+end_example

** 版本 - ~$ver~
见[[#版本化][版本化]]。

* Body
示例中，只包含与上下文有关的 ~Http Header~ 。

** 关于服务端生成的内容的属性项的特殊说明
在客户端的服务端通信，产生内容的过程中，有不少信息是需要由服务端生成。

例如：
- 根据 ~当前登陆用户~ 计算生成的属性
- 实体的 ~主键~
- ~创建时间~
- ~修改时间~

这类属性，应一直保持由服务端生成。

即便客户端提交了，也应该忽略。

不少具有 ~写入操作~ 特性的请求，成功之后是需要返回实体。

因为客户端虽然掌握自身提交的信息，也需要这些 ~由服务端生成内容~ 的属性，
如果不在响应中返回新的实体信息，客户端需要额外多发出依次请求。

网络上的性能损耗，远远大于根据主键的数据库查询。

接下来的内容中，涉及到 ~服务端生成内容~ 的字段时，不过多说明。

** 关于 ~JSON~ 中 ~数据类型~ 和 ~默认值~ 的说明
[[https://www.json.org/json-en.html][JSON]]作为Javascript对象表示法，天然只支持Javascript中的数据类型。

任何动态类型语言的最佳实践中，都不推荐中途改变类型的做法。

Javascript是动态类型语言，也应该尊重这样的实践经验，相应地 ~JSON~ 也是如此。

不幸的是我们不能简单地把Javascript中的 ~null~ 按常识理解为 ~所有类型~ 的 ~空值~ 。

因为它的类型是 ~object~ ， 使用 ~null~ 你会有意无意地 *中途改变类型* 。

Javascript中最接近 ~所有类型~ 的 ~空值~ 的类型是 ~undefined~ 。

但 ~JSON~ 合法的数据类型中，恰恰又不包含 ~undefined~ 。

不管你喜不喜欢，这是历史决定的事实。

好在Javascript中，一个变量 ~尚未被声明~ ， ~已声明但未赋值~ 都是 ~undefined~ 。

所以在 ~JSON~ 中，希望表达与常识中 ~所有类型~ 的 ~空值~ 等价的含义，
#+begin_quote
与其为一个字段赋 ~null~ 值，不如干脆不要让这样的字段出现在 ~JSON~ 对象中。
#+end_quote

很多框架和处理 ~JSON~ 的工具库中，都提供了专门如何处理 ~null~ 的配置选项。

再插入题外话，

MySQL作为免费开源又稳定的关系型数据库，很长一段时间里成为了我们的最佳选择。

在使用MySQL数据库的时候，因为NULL无法被索引，
为了必要时能够及时创建索引，基本类型字段通常都不允许为NULL。

数值类型字段，为了尽可能存储更大的数值，通常也会使用无符号的整型。

但这么做，会产生一个问题。
#+begin_quote
如何在逻辑上表示“空”呢？
#+end_quote

具体做法是
#+begin_quote
约定默认值!
#+end_quote

如果某个字段的值为“默认值”，代表“尚未有意图地设定值”。

下方是在这样的“约定”下，比较常见的数据库表字段的定义方式。
#+begin_src sql
CREATE TABLE `example` (
    `string` varchar(100) NOT NULL DEFAULT '',
    `number` int(10) unsigned NOT NULL DEFAULT 0,
    `tiny_number` tinyint(3) unsigned NOT NULL DEFAULT 0,
    `large_number` bigint(20) unsigned NOT NULL DEFAULT 0,
    `decimal` decimal(10,2) unsigned NOT NULL DEFAULT 0.00,
    `boolean` bit(1) NOT NULL DEFAULT b'0',
    `iso8601` datetime(6) NOT NULL DEFAULT current_timestamp(6)
);
#+end_src

虽然是“君子约定”，但这样的做法可以为我们创造“干净”的世界。

在程序代码中各种 ~判断为空~ 的场景下
- ~字符串~ 类型不再需要先检查是不是 ~null~ 再检查长度是否为 ~0~ 。
- ~数值~ 类型不再需要先检查是不是 ~null~ 再检查是否为 ~0~ 。
- ~数组~ 类型不再需要先检查是不是 ~null~ ，是不是数组，再检查是否长度为 ~0~ 。

对于任何类型， ~判断为空~ 的方法只有一种，非常确定的唯一的一种。

即便出现了“小人”，“君子”毕竟有人数上的优势......

把这样的实践应用到我们的 ~JSON~ 中，就会得到如下的“约定”。

*** 君子约定
#+begin_example
{
    "field_string": "", # 默认值为空字符串
    "field_number": 0, # 默认值为0
    "field_object": null, # 值为JSON object时是唯一可能出现null的情况
    "field_array": [], # 默认值为空数组
    "field_boolean": false, # Boolean无歧义，默认值可为false，可为true
    "field_undefined": undefined, # 其他情况的空，干脆别让它出现在JSON中
}
#+end_example

** 单实体
*** 探 - HEAD
可用来判断有没有。

#+begin_example
# 请求
# Request Method: HEAD
# Request URL: /image/abc.xml

# 响应
# Status Code: 404 Not Found
#+end_example

也可用来获取资源的Meta信息，比如大小、最后修改时间等。
#+begin_example
# 请求
# Request Method: HEAD
# Request URL: /image/86108637-8cc5-40ea-b9ec-d6ac83bbf13a.png

# 响应
# Status Code: 200 Ok
# Date: Wed, 04 Sep 2024 10:33:11 GMT
# Content-Type: image/png
# Content-Length: 3241341
#+end_example

*** 增 - POST
相当于SQL中的INSERT，默认返回[[#基本实体][基本实体]]。

可根据 ~query~ 参数改变响应的实体内容。

#+begin_example
# 请求
# Request Method: POST
# Request URL: /post
{
    "title": "合理设计RESTful API",
    "category": "14",
    "content": "..... ...... ......",
}

# 响应
# Status Code: 201 Created
{
    "id": "1234513432",
    "title": "合理设计RESTful API",
    "category": "14",
    "author": "23",
    "content": "..... ...... ......",
    "deleted": false,
    "ctime": "2024-08-23T21:43:21.234Z",
    "utime": "2024-08-23T21:43:21.234Z",
}
#+end_example

*** 删 - DELETE
相当于SQL中的DELETE，服务端实现大多数为软删除。

成功时以 ~204~ 响应， ~Body~ 中不需要返回任何内容。

#+begin_quote
Why 204?
#+end_quote

- 返回被删除的对象，需要至少执行两次SQL语句。
- 设计上应该用户确认在先，然后再提交删除操作。

#+begin_example
# 请求
# Request Method: DELETE
# Request URL: /post/1234513432

# 响应
# Status Code: 204 No Content
#+end_example

对于重复的删除请求，有两种实现策略，二选一即可。

- 幂等成功，以 ~204~ 响应。
- 返回资源不存在，以 ~404~ 响应。

*** 替 - PUT
相当于SQL中的UPDATE，Body相当于SET的参数，URL相当于WHERE。

提交的实体中，应该包含由客户端产生内容的所有属性。

未包含的属性
- 如果允许为空，则应该被“清空”（用默认值填充）。
- 如果不允许为空，则应该用[[#400---其他客户端异常][400 - 其他客户端异常]]响应。

默认返回[[#基本实体][基本实体]]，可根据 ~query~ 参数改变响应的实体内容。

#+begin_example
# 请求
# Request Method: PUT
# Request URL: /post/1234513432
{
    "title": "合理设计RESTful API",
    "category": "14",
    "author": "23",
    "content": "..... ...... ......",
}

# 响应
# Status Code: 200 Ok
{
    "id": "1234513432",
    "title": "合理设计RESTful API",
    "category": "14",
    "author": "23",
    "content": "..... ...... ......",
    "deleted": false,
    "ctime": "2024-08-23T21:43:21.234Z",
    "utime": "2025-03-15T12:07:59.234Z",
}
#+end_example

*** 改 - PATCH
相当于SQL中的UPDATE，Body相当于SET的参数，URL相当于WHERE。

提交的实体中，只需要包含希望修改的属性即可。

默认返回[[#基本实体][基本实体]]，可根据 ~query~ 参数改变响应的实体内容。

#+begin_example
# 请求
# Request Method: PATCH
# Request URL: /post/1234513432
{
    "title": "合理设计RESTful API",
    "content": "..... ...... ......",
}

# 响应
# Status Code: 200 Ok
{
    "id": "1234513432",
    "title": "合理设计RESTful API",
    "category": "14",
    "author": "23",
    "content": "..... ...... ......",
    "deleted": false,
    "ctime": "2024-08-23T21:43:21.234Z",
    "utime": "2025-03-15T12:07:59.234Z",
}
#+end_example

*** 查 - GET
相当于SQL中的SELECT，URL相当于WHERE。

默认返回[[#基本实体][基本实体]]，可根据 ~query~ 参数改变响应的实体内容。

#+begin_example
# 请求
# Request Method: GET
# Request URL: /post/1234513432

# 响应
# Status Code: 200 Ok
{
    "id": "1234513432",
    "title": "合理设计RESTful API",
    "category": "14",
    "author": "23",
    "content": "..... ...... ......",
    "deleted": false,
    "ctime": "2024-08-23T21:43:21.234Z",
    "utime": "2025-03-15T12:07:59.234Z",
}
#+end_example

**** 属性挑选 - ~$pick~
#+begin_example
# 请求
# Request Method: GET
# Request URL: /post/1234513432?$pick=title&$pick=content&$pick=ctime

# 响应
# Status Code: 200 Ok
{
    "title": "合理设计RESTful API",
    "content": "..... ...... ......",
    "ctime": "2024-08-23T21:43:21.234Z",
}
#+end_example

**** 属性排除 - ~$omit~
#+begin_example
# 请求
# Request Method: GET
# Request URL: /post/1234513432?$omit=category&$omit=author&$omit=deleted&$omit=ctime

# 响应
# Status Code: 200 Ok
{
    "id": "1234513432",
    "title": "合理设计RESTful API",
    "content": "..... ...... ......",
    "utime": "2025-03-15T12:07:59.234Z",
}
#+end_example

**** 属性扩展 - ~$embed~
#+begin_example
# 请求
# Request Method: GET
# Request URL: /post/1234513432?$embed=category&$embed=author

# 响应
# Status Code: 200 Ok
{
    "id": "1234513432",
    "title": "合理设计RESTful API",
    "category": {
        "id": "14",
        "pid": "7",
        "text": "规约设计",
        "deleted": false,
        "ctime": "2024-08-23T21:43:21.234Z",
        "utime": "2025-03-15T12:07:59.234Z",
    },
    "author": {
        "id": "1432414132",
        "nickname": "夏天的虫子",
        "username": "hanzhixing"
        "deleted": false,
        "ctime": "2024-08-23T21:43:21.234Z",
        "utime": "2025-03-15T12:07:59.234Z",
    },
    "content": "..... ...... ......",
    "deleted": false,
    "ctime": "2024-08-23T21:43:21.234Z",
    "utime": "2025-03-15T12:07:59.234Z",
}
#+end_example

** 多实体
*** 探 - HEAD
应用场景不是很多。

#+begin_example
# 请求
# Request Method: HEAD
# Request URL: /post?category=23

# 响应
# Status Code: 200 Ok
# X-Total-Count: 34
#+end_example

*** 增 - POST
部分成功可以用[[#400---其他客户端异常][400 - 其他客户端异常]]返回异常。

默认返回[[#基本实体][基本实体]]，可根据 ~query~ 参数改变响应的实体内容。

#+begin_example
# 请求
# Request Method: POST
# Request URL: /post
[
    {
        "title": "合理设计RESTful API",
        "category": "14",
        "content": "..... ...... ......",
    },
    {
        "title": "设计高可用架构的方法",
        "category": "14",
        "content": "..... ...... ......",
    }
]

# 响应
# Status Code: 201 Created
[
    {
        "id": "1234513432",
        "title": "合理设计RESTful API",
        "category": "14",
        "author": "23",
        "content": "..... ...... ......",
        "deleted": false,
        "ctime": "2024-08-23T21:43:21.234Z",
        "utime": "2024-08-23T21:43:21.234Z",
    }
    {
        "id": "1234513432",
        "title": "设计高可用架构的方法",
        "category": "14",
        "author": "23",
        "content": "..... ...... ......",
        "deleted": false,
        "ctime": "2024-08-23T21:43:21.234Z",
        "utime": "2024-08-23T21:43:21.234Z",
    }
]
#+end_example

*** 删 - DELETE
部分成功可以用[[#400---其他客户端异常][400 - 其他客户端异常]]返回异常。

成功不需要返回任何内容。

#+begin_example
# 请求
# Request Method: DELETE
# Request URL: /post?id=3413&id=5353

# 响应
# Status Code: 204 No Content
#+end_example

*** 替 - PUT
~主键~ 需要放到实体结构中。

提交的实体中，应该包含由客户端产生内容的所有属性。

未包含的属性
- 如果允许为空，则应该被“清空”（用默认值填充）。
- 如果不允许为空，则应该用[[#400---其他客户端异常][400 - 其他客户端异常]]响应。

部分成功可以用[[#400---其他客户端异常][400 - 其他客户端异常]]返回异常。

默认返回[[#基本实体][基本实体]]，根据 ~query~ 参数相应地改变返回内容。

#+begin_example
# 请求
# Request Method: PUT
# Request URL: /post
[
    {
        "id": "1234513432",
        "title": "合理设计RESTful API",
        "category": "14",
        "author": "23",
        "content": "..... ...... ......",
    },
    {
        "id": "2234513432",
        "title": "设计高可用架构的方法",
        "category": "14",
        "author": "23",
        "content": "..... ...... ......",
    }
]

# 响应
# Status Code: 200 Ok
[
    {
        "id": "1234513432",
        "title": "合理设计RESTful API",
        "category": "14",
        "author": "23",
        "content": "..... ...... ......",
        "deleted": false,
        "ctime": "2024-08-23T21:43:21.234Z",
        "utime": "2024-08-23T21:43:21.234Z",
    }
    {
        "id": "2234513432",
        "title": "设计高可用架构的方法",
        "category": "14",
        "author": "23",
        "content": "..... ...... ......",
        "deleted": false,
        "ctime": "2024-08-23T21:43:21.234Z",
        "utime": "2024-08-23T21:43:21.234Z",
    }
]
#+end_example

*** 改 - PATCH
~主键~ 需要放到实体结构中。

提交的实体中，只需要包含希望修改的属性即可。

部分成功可以用[[#400---其他客户端异常][400 - 其他客户端异常]]返回异常。

默认返回[[#基本实体][基本实体]]，根据 ~query~ 参数相应地改变返回内容。

#+begin_example
# 请求
# Request Method: PATCH
# Request URL: /post
[
    {
        "id": "1234513432",
        "content": "..... ...... ......",
    },
    {
        "id": "2234513432",
        "title": "设计高可用架构的方法",
    }
]

# 响应
# Status Code: 200 Ok
[
    {
        "id": "1234513432",
        "title": "合理设计RESTful API",
        "category": "14",
        "author": "23",
        "content": "..... ...... ......",
        "deleted": false,
        "ctime": "2024-08-23T21:43:21.234Z",
        "utime": "2024-08-23T21:43:21.234Z",
    }
    {
        "id": "2234513432",
        "title": "设计高可用架构的方法",
        "category": "14",
        "author": "23",
        "content": "..... ...... ......",
        "deleted": false,
        "ctime": "2024-08-23T21:43:21.234Z",
        "utime": "2024-08-23T21:43:21.234Z",
    }
]
#+end_example


*** 查 - GET
更多查询方式参考[[#query][Query]]。

#+begin_example
# 请求
# Request Method: GET
# Request URL: /post?category=14&$embed=author&$omit=deleted&$omit=ctime

# 响应
# Status Code: 200 Ok
[
    {
        "id": "1234513432",
        "title": "合理设计RESTful API",
        "category": "14",
        "author": {
            "id": "1432414132",
            "nickname": "夏天的虫子",
            "username": "hanzhixing"
            "deleted": false,
            "ctime": "2024-08-23T21:43:21.234Z",
            "utime": "2025-03-15T12:07:59.234Z",
        },
        "content": "..... ...... ......",
        "utime": "2024-08-23T21:43:21.234Z",
    }
    {
        "id": "1234513432",
        "title": "设计高可用架构的方法",
        "category": "14",
        "author": {
            "id": "1432414132",
            "nickname": "夏天的虫子",
            "username": "hanzhixing"
            "deleted": false,
            "ctime": "2024-08-23T21:43:21.234Z",
            "utime": "2025-03-15T12:07:59.234Z",
        },
        "content": "..... ...... ......",
        "utime": "2024-08-23T21:43:21.234Z",
    }
]
#+end_example

*** 搜 - ~$keyword~
更多查询方式参考[[#query][Query]]。

#+begin_example
# 请求
# Request Method: GET
# Request URL: /post?$keyword=设计&$pick=id&$pick=title&$pick=utime

# 响应
# Status Code: 200 Ok
[
    {
        "id": "1234513432",
        "title": "合理设计RESTful API",
        "utime": "2024-08-23T21:43:21.234Z",
    }
    {
        "id": "1234513432",
        "title": "设计高可用架构的方法",
        "utime": "2024-08-23T21:43:21.234Z",
    }
]
#+end_example

* 特殊操作示例
** 针对vip用户开启自动置顶的功能
这其实算不上特殊操作。

在这里举例说明，也是想传达：RESTful架构的实践中转变思维模式很重要。

#+begin_example
# 请求
# Request Method: PATCH
# Request URL: /system_configuration/POST_RELATED
{
    "auto_sticky": "ON"
}

# 响应
# Status Code: 200
{
    ...
    ...
    "auto_sticky": "ON"
    ...
    ...
    "auto_trash_cleaning": "30days",
    ...
}
#+end_example

** 所有vip用户写的文章的所有评论中找出点赞数是4星以上的评论
查询的目标集合与3个以上关联资源有关时，都会出现此类问题。

假设vip这个角色对象的实体ID为123。

#+begin_example
# 请求
# Request Method: GET
# Request URL: /role/123/post/$all/comment?star>=4
#+end_example

** 获取当前登陆用户的基本信息
#+begin_example
# 请求
# Request Method: GET
# Request URL: /session/$current/user

# 响应
# Status Code: Ok
{
    "id": "3241413143",
    "username": "hanzhixing",
    "nickname": "夏天的虫子",
    "mobile": "12345678901",
    "deleted": false,
    "ctime": "2024-08-23T21:43:21.234Z",
    "utime": "2024-08-23T21:43:21.234Z",
}
#+end_example

** 获取当前登陆用户的角色
#+begin_example
# 请求
# Request Method: GET
# Request URL: /session/$current/role

# 响应
# Status Code: Ok
{
    "id": "6436432",
    "name": "vip",
    "deleted": false,
    "ctime": "2024-08-23T21:43:21.234Z",
    "utime": "2024-08-23T21:43:21.234Z",
}
#+end_example

** 退出登陆
见[[#登陆身份验证退出登陆][登陆、身份验证、退出登陆]]。

** 文章的收藏和取消收藏
收藏和取消收藏，比较难想到的是：它操作的实体的属性与当前登陆用户有关。

还有就是实际操作的并不是文章实体，而是文章和用户的关联关系对象。

假设保存该关系的表名是 ~post_favorite~ ，

假如数据保存结构是
|   id | user_id | post_id |
|------+---------+---------|
| 3413 |     134 |   15132 |

- 收藏
  #+begin_example
  # 请求
  # Request Method: POST
  # Request URL: /post_favorite
  {
      "post_id": "15132"
  }

  # 响应
  # Status Code: 201
  {
      "id": "3413",
      "user_id": "134",
      "post_id": "15132"
  }
  #+end_example

- 取消收藏
  #+begin_example
  # 请求
  # Request Method: DELETE
  # Request URL: /post_favorite/3413

  # 响应
  # Status Code: 204 No Content
  #+end_example

假如数据保存结构是
| user_id |    post_id |
|---------+------------|
|     134 | 1513241343 |

- 收藏
  #+begin_example
  # 请求
  # Request Method: POST
  # Request URL: /post_favorite
  {
      "post_id": "15132"
  }

  # 响应
  # Status Code: 201
  {
      "user_id": "134",
      "post_id": "15132"
  }
  #+end_example

- 取消收藏
  #+begin_example
  # 请求
  # Request Method: DELETE
  # Request URL: /post_favorite?post_id=15132

  # 响应
  # Status Code: 204 No Content
  #+end_example

这里 ~user_id~ 的处理，其实和用户提交文章时，
文章的 ~author~ 属性用当前登陆用户的user_id填充是一样的逻辑。

和 ~post~ 一样，需要根据当前登陆用户身份进行必要的校验。

** 查询条件非常复杂的搜索功能
这类操作与RESTful的矛盾在于，查询本应该是 ~GET~ ，但只通过 ~Query~ 参数，
我们无法描述特别复杂的查询条件。

我建议用 ~POST~ 。

在 ~Query~ 中实现特殊的 ~DSL~ 的方案，随着时间的推移会产生很多问题，
解决这些问题也会有层层阻碍阻碍。

但利用像 ~JSON~ 这样结构化的数据来描述复杂的查询条件，会轻而易举。

这类查询，有可能跨资源，也有可能是单个资源，但解决思路都是一样的。

我们可以在API层抽象虚拟的实体类型，如: ~search~ 或者 ~retrive~ 。

这里以使用 ~search~ 为例。

*** 第一步
客户端提交一个新的 ~search~ 对象。
  #+begin_example
  # 请求
  # Request Method: POST
  # Request URL: /post/$all/search
  {
      ......
      描述
      ......
      非常
      ......
      复杂的
      ......
      查询条件的
      ......
      信息
      ......
  }
  #+end_example

*** 第二步
服务端为这个 ~search~ 对象生成唯一ID，建议用 ~UUID~ 。

以生成的ID作为主键，把该 ~search~ 对象保存到内存数据库中。

（关系型数据库也不是不行，只要你想。只不过对象存储更适合。）

*** 第三步
下面两种方案二选一。

**** 服务端以 ~201~ 响应
#+begin_example
# 响应
Status Code: 201 Created
{
    "uuid": "498b882a-25d1-4305-ace7-e76bfc0fa48c",
    ......
    描述
    ......
    非常
    ......
    复杂的
    ......
    查询条件的
    ......
    信息
    ......
}
#+end_example

客户端得到响应之后，根据 ~uuid~ 再次发起查询请求。

服务端根据 ~uuid~ 查询到第一步保存的 ~search~ 对象，
执行真正的查询，并返回结果。

#+begin_example
# 请求
# Request Method: GET
# Request URL: /post/$all/search/498b882a-25d1-4305-ace7-e76bfc0fa48c/result

# 响应
# Status Code: 200 Ok
{
    ......
    返回实际查询结果
    ......
}
#+end_example

**** 服务端以 ~302~ 响应
如果客户端是浏览器，浏览器会自动重定向，发起后续请求。

从浏览器的视角上看，相当于一次 ~POST~ 请求直接返回了真正查询结果。

#+begin_example
# 响应
Status Code: 302 Found
Location: /post/$all/search/498b882a-25d1-4305-ace7-e76bfc0fa48c/result

# 重定向请求
# Request Method: GET
# Request URL: /post/$all/search/498b882a-25d1-4305-ace7-e76bfc0fa48c/result

# 最终响应
# Status Code: 200 Ok
{
    ......
    返回实际查询结果
    ......
}
#+end_example

*** 额外收获
这样的方法看似复杂，但实际实现起来并不难。

这么做还有一个优点。

既然查询条件非常复杂，一定是用户花了很多时间辛辛苦苦构造出来的。

采用这种方式，正好可以优化功能，让用户可以把查询条件保存起来。

下次再使用相同的查询条件的时候，直接可以利用之前保存好的，不用重新构造。

甚至基于已经保存好的查询条件，修改一部分派生出新的查询条件。

* 登陆、身份验证、退出登陆
** [[https://jwt.io/][JWT]]
*** 登陆
#+begin_example
# 请求
# Request Method: POST
# Request URL /session
{
    "method": "email",
    "email": "John@example.com",
    "password": "1234324134"
}

# 响应
# Status Code: 201 Created
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.KMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30
#+end_example

*** 身份验证
所有请求都需要带上 ~token~ 。

#+begin_example
# 请求
# Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.KMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30
#+end_example

成功时以 ~2XX~ 正常响应，失败时以 ~401~ 响应。

*** 退出登出
客户端删除 ~token~ 即可。

** Cookie
*** 登陆
#+begin_example
# 请求
# Request Method: POST
# Request URL /session
{
    "method": "email",
    "email": "username@example.com",
    "password": "1234567890"
}

# 响应
# Status Code: 201 Created
Set-Cookie: sessid=AKEyXzU-3AaVGhwNSrwaKJsxg0; expires=Mon, 16-Mar-2024 13:09:58 GMT; path=/; domain=.example; Secure; HttpOnly; priority=high; SameSite=Lax
#+end_example

*** 身份验证
所有请求都需要带上 ~Cookie~ 。

#+begin_example
# 请求
# Cookie: sessid=AKEyXzU-3AaVGhwNSrwaKJsxg0
#+end_example

成功时以 ~2XX~ 正常响应，失败时以 ~401~ 响应。

*** 退出登出
#+begin_example
# 请求
# Request Method: DELETE
# Request URL /session/$current

# 响应
# Status Code: 204 No Content
#+end_example

* CSRF (Cross Site Request Forgery)
#+begin_quote
只在浏览器环境中，并且使用Cookie来做身份验证的场景下才适用。
#+end_quote

服务端需要为每个客户端，生成有短时间内有效的，随机字符串作为token。

建议使用UUID。

响应客户端请求时，通过Cookie把该token返回给浏览器。
#+begin_example
# 响应
Set-Cookie: csrf_token=5b3cc03a-b485-4a2d-991a-fa11f5381a0d; expires=Mon, 16-Mar-2024 13:09:58 GMT; path=/; domain=.example; Secure; priority=high; SameSite=Lax
#+end_example

在请求合法的情况下，需要检查Cookie过期实践，及时更新新的token并返回。

不能设置为 ~HTTPOnly~ ，因为该token是需要由Javascript读取。

（正因为需要使用 ~HTTPOnly~ ， ~XSS~ 的防范是必须的）

~csrf_token~ 建议全部字符小写。

客户端向服务端发起 ~POST~ , ~PUT~ , ~PATCH~ , ~DELETE~ 等带有“写操作”特性的
请求时，使用Javascript读取Cookie中的 ~csrf_token~ ，
把它放到 ~X-Csrf-Token~ 头中一起发送。
#+begin_example
# 请求
Request Method: POST
X-Csrf-Token: 5b3cc03a-b485-4a2d-991a-fa11f5381a0d
#+end_example

* 国际化
#+begin_example
# 请求
Accept-Language: zh-CN;q=0.8,zh;q=0.6,en-US;q=0.4,en;q=0.2

# 响应
Content-Language: zh-CN
#+end_example

* 版本化
使用[[https://semver.org/][Semantic Versioning]]。

版本化会为新旧并存、无损重构、平滑升级、请求分发、流量控制等创造很多便利条件，
同时也为API的用户提供方便。

在 ~Path~ 中包含 ~MAJOR~ 位来表示协议架构或 ~Schema~ 层面的版本。

该版本为协议架构，而非应用程序的架构，程序架构升级和API协议结构并不是一回事。

例如，改变了身份验证、权限验证方式，废弃了一些用户已经在使用的 ~Header~ ，
改变了 ~Body~ 的基本结构等向后不兼容的变更为协议架构层面。

这种改变的特点是会影响所有或者很大一部分既有的API调用，
这时应该在另一个 ~MAJOR~ 版本路径上部署新的API。

#+begin_example
/rest/v1/...
/api/v3/...
#+end_example

在 ~Query~ 中用 ~$ver~ 参数指定完整版本，未包含时始终调用最新版本。

#+begin_example
/rest/v1/posts/123?$ver=v1.1.0
/rest/v1/posts/123?$ver=v1.1.5
#+end_example

* 缓存
一般作用于浏览器，因为它实现了识别缓存策略，并根据策略决定下一步操作的逻辑。

由于都是标准Header，建议查阅[[https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers][HTTP headers (MDN)]]。

** 请求头
*** [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/If-None-Match][If-Non-Match]]
服务器用它来判断是否返回全新的资源。

与 ~ETag~ 搭配使用。

*** [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/If-Modified-Since][If-Modified-Since]]
服务器用它来判断是否返回全新的资源。

与 ~Last Modified~ 搭配使用。

** 响应头
一般是通过Web Server指令配置，配置方式通常比较简单。

*** [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cache-Control][Cache-Control]]
缓存相关的 *最重要* 的Header。控制缓存策略。

*** [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/ETag][ETag]]
资源版本。

与请求头 ~If-Non-Match~ 搭配。
*** [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Last-Modified][Last-Modified]]
最后变更时间。

通常在无法使用 ~ETag~ 时作为替代使用。

与请求头 ~If-Modified-Since~ 搭配。

*** [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Expires][Expires]]
由于依赖客户端和服务端的时间一致性，优先级较低，也容易被忽略。

** 优先级
[ ~If-Non-Match~ + ~Etag~ ] > [ ~If-Modified-Since~ + ~Last-Modified~ ]。

前者出现，会忽略后者。

* 频率限制
** 正常服务
#+begin_example
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 73
X-RateLimit-Rest: 1742112652
#+end_example

** 拒绝服务
#+begin_example
Status Code: 429 Too Many Requests
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Rest: 1742112652
Retry-After: 120
#+end_example

* 分片传输
无需特殊约定，只要Web服务器允许分片传输，即可按HTTP标准使用。

* 特殊网络环境

** X-HTTP-Method-Override
网络环境中有的代理服务可能只支持GET和POST方法

应协商自定义的HTTP Header来标识PUT、DELETE等请求。

#+begin_example
Request Method: GET
X-HTTP-Method-Override: PUT
#+end_example

* 未经授权，禁止转载，转载请注明出处
转载不能修改原文的标题和内容。
