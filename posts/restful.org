#+title: 合理设计RESTful API
#+OPTIONS: ^:{}
#+PANDOC_OPTIONS: css:'https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css'

* 原则
图形界面作为面向用户的用户接口，一般都需要考虑用户体验。

API作为面向开发者的用户接口协议，同样需要精心的设计。

1. 简单、直观、统一。
2. 便于记忆，维护成本低。
3. 无歧义，预期稳定且唯一。
4. 高兼容性的协议，更容易适用更多的客户端形式。
5. 尽可能遵守业界公认标准或惯例，这么做后续平滑升级，新人培训都可低成本完成。
6. 查阅者体验优先。协议文档以网页形式共享，而不用Word, Excel等文件形式。

* 写在前面
API和数据库都是描述各种实体对象和它们属性。

但是从分层架构的视角看，数据库和API处在不同的分层中，职责也会有差别。

数据库是为服务端的业务层服务的，而API是服务客户端的。

API中有些信息可能直接从文件中读取，
或者来自内存缓存，消息队列，索引系统，其他子系统等等，
甚至有可能是组合构造全新的虚拟实体对象。

所以如果API协议中出现了数据库的表名、字段名，那也是“ *碰巧* ”，
而不是它本“应该”就那样。

你永远要努力向客户端屏蔽或隐藏它不需要知道的信息。

暴露的信息越多，升级或重构的时候你付出的代价就越大。

* 特殊信息
** 大数值字段 - 字符串
它之所以特殊，是因为很多数据库考虑到性能因素，ID字段都设置为数字类型。

比如：TINYINT, INT, BIGINT, unsigned BIGINT等。

但不同计算环境中，大数值数字的处理方式不一样。

特别是浏览器中，Javascript的Number类型是以64位的浮点数来标识的。

如果使用unsigned BIGINT，而刚好数值范围超出的浏览器能够处理的范围，
那么就有可能产生信息丢失或错误。

为了保险起见，这样的属性字段，在API中要使用字符串类型。

** 日期和时间 - ISO8601
日期和时间，因为涉及时区，涉及到Timestamp, GMT, UTC, CST等不同表达方式。

如果不统一，会产生很多问题。

一律按照ISO8601的标准表达Datetime。

以最终存储精度为准，记录最精确的时间。

- 精确到秒: ~YYYY-MM-DDTHH:mm:ssZ~

  例如：2023-09-12T00:18:25Z

- 精确到毫秒: ~YYYY-MM-DDTHH:mm:ss.sssZ~

  例如：2023-09-12T00:18:25.532Z

- 精确到微秒: ~YYYY-MM-DDTHH:mm:ss.ssssssZ~

  例如：2023-09-12T00:18:25.513551Z

* 《元实体》和 《富实体》
RESTful API的后端，通常都是关系型数据库。

在关系型数据库的语境中，信息通常是 *范式化* 存储。

（见：[[https://en.wikipedia.org/wiki/Database_normalization][Database normalization）]]

基于这个背景，为了表述上的方便，定义两个概念。

后续的内容中如果有必要，可能会使用这两个概念。

注意观察 ~category~ 和 ~author~ 两个属性的区别。

*** 元实体
没有扩展关联对象的结构。
#+begin_example
{
    "id": "1234513432",
    "title": "合理设计RESTful API",
    "category": "14",
    "author": "23",
    "content": "..... ...... ......",
    "deleted": false,
    "ctime": "2024-08-23T21:43:21Z",
    "utime": "2025-03-15T12:07:59Z",
}
#+end_example

*** 富实体
扩展了关联对象的结构。
#+begin_example
{
    "id": "1234513432",
    "title": "合理设计RESTful API",
    "category": {
        "id": "14",
        "pid": "7",
        "text": "规约设计",
        "deleted": false,
        "ctime": "2023-12-07T21:43:21Z",
        "utime": "2023-12-07T21:43:21Z",
    },
    "author": {
        "id": "1432414132",
        "nickname": "夏天的虫子",
        "username": "hanzhixing"
        "deleted": false,
        "ctime": "2023-12-07T21:43:21Z",
        "utime": "2023-12-07T21:43:21Z",
    },
    "content": "..... ...... ......",
    "deleted": false,
    "ctime": "2024-08-23T21:43:21Z",
    "utime": "2025-03-15T12:07:59Z",
}
#+end_example

* URI 和 URL
详见 [[https://en.wikipedia.org/wiki/Uniform_Resource_Identifier][Wikipedia URI]] 和 [[https://en.wikipedia.org/wiki/URL][Wikipedia URL]] 的说明。

#+begin_example
          userinfo       host      port
          ┌──┴───┐ ┌──────┴──────┐ ┌┴┐
  https://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top
  └─┬─┘   └─────────────┬────────────┘└───────┬───────┘ └────────────┬────────────┘ └┬┘
  scheme          authority                  path                  query           fragment
#+end_example

本文章中或多或少会直接使用这些术语。

* 命名风格
与计算机语言类似，RESTful风格的API协议中，我们也应该明确规定“标识符”的合法字符。

非常多的计算机语言中，由于考虑与 ~-~ 的冲突，
在变量名或者方法名等标识符中不允许出现 ~-~ 。

常见计算机语言中，标识符中可用的合法安全字符通常由 ~[A-Za-z0-9_]~ 构成。

从命名规范来看下面这几个用的最多。

- ~camelCase~
- ~PascalCase~
- ~snake_case~
- ~kebab-case~
- ~SCREAMING_SNAKE_CASE~

尽管API协议不受服务端或者客户端所使用的计算机语的约束，
但在不同语言中处理API协议中的标识符的时候，
通常需要较低成本就可以转换成自身语言中的标识符。
我们也经常使用自动映射工具来完成这种转换。
很多计算机语言都可以找到命名风格转换的工具。

所以，首先

#+begin_quote
计算机能够自动转换风格是 *底线* 。
#+end_quote

退而求其次，考虑到跨不同计算机语言的兼容性，我们应该

#+begin_quote
避免使用 ~kebab-case~ 。
#+end_quote

有很多计算机语言的标识符中不能包含 ~-~ 。

在一些不区分大小写的系统中 ~PascalCase~ , ~camelCase~
这种以大小写来确定词汇边界的命名方式，
极有可能变成 ~pascalcase~ , ~camelcase~ 。

如果我们把时间看得足够长，
我们就有机会在区分大小写的系统和不区分大小写的系统之间传播文件名等信息。
这大大增大了冲突或者被覆盖的概率。

大小写的差别消失之后，靠计算机来辨别原本存在的那些词汇边界会变得比较困难，
即便是人有的时候也需要花费精力才能辨别。

眼下业界被认同的惯例是（考虑到客户端的开发者体验、性能成本等因素）

#+begin_quote
尽量以符合客户端所使用的语言的命名规范来设计API协议
#+end_quote

但我们也要考虑服务端会由各式各样的使用不同语言实现的多种客户端进行消费。

这些语言之间，很大概率命名风格也不一样。

#+begin_quote
据统计 ~snake_case~ 风格比 ~camelCase~ 要容易阅读 *20%* 左右!
#+end_quote

所以综合考虑

#+begin_quote
应该优先使用 ~snake_case~ 。
#+end_quote

还有有些人可能没有注意到

#+begin_quote
在浏览器和绝大多数的软件中，
双击鼠标去选中标识符的时候， ~snake_case~ 一般能够完整的被选中，
复制比较方便。
#+end_quote

* Meta
#+begin_quote
计算机领域 *Meta* 通常指“ *描述数据的数据* ”或“ *关于数据的数据* ”。
#+end_quote

在RESTful风格的API协议设计中，
仅靠“实体”（例如“用户”）和“实体属性”（例如“用户”的“邮箱”），
是不足以表达我们需要的所有信息。

因此需要设置一些Meta变量来承载那些信息。

Meta信息的标识经常与“实体”和“实体属性”标识一起出现，
所以我们需要使用特殊字符防止它们和Meta信息的冲突。

计算机语言中使用比较多的有 ~$~ 和 ~_~ ，因为肉眼比较好识别。

但 ~$~ 上下匀称，更好看一些。

* Path
** 不使用动词，而是使用名词
RESTful风格的协议中，

用 *Http Method* 来回答： *做什么操作？*

- ~HEAD~: 探
- ~POST~: 增
- ~PATCH~: 改
- ~PUT~: 替
- ~GET~: 查
- ~DELETE~: 删

用 *URL* 来回答： *资源在哪里？*

#+begin_example
# Good!
/post/56/comment
/user/1341/post

# Evil!
/getPosts
/getUsers
/listPosts
/fetchAllComments
#+end_example

如果你执意把“ *做什么操作？* ”的信息放进URL中，
反而会给协议的使用者和维护者带来困惑。
#+begin_quote
到底在什么时候用get，什么时候用list，什么时候用fetch?
#+end_quote

** 使用单数，而不是复数
这一点可能会和你在网络上找到的RESTful最佳实践中的恰恰相反，
有不少文章是推荐使用复数。

例如：
- ~/posts~ 来表达“获取多个帖子”。
- ~/posts/123~ 来表达“在多个帖子中选择编号为123的那个帖子”。

如果用自然语言来理解，这样的确会更自然一些。

但是英语中有很多单复数不规则名词。

例如：
- ~people~ 既可以是“人”，也可以是“人民”。
- ~sheep~ 则单复数相同。
- ~axis~ 的复数既可以用 ~axes~ ，也可以用 ~axises~ 。
- ~criterion~ 的复数可以用 ~criteria~ 或 ~criterions~ 。

甚至，国内一些项目中也有 ~childs~ 当作 ~child~ 复数来使用的例子，
而 ~childs~ 实际为人名“蔡尔兹”。

笔者过去几年，也是复数的忠实粉丝，因为觉得复数更讲“人话”。

但是经历了几年的实践，经受了复数的各种摧残，再也不会纠结。

因为一定会使用“ *单数* ”。

我们在国内环境勉强可以自欺欺人地认为可以适当牺牲英语中精确的词法来换API表达的直观和易懂，但是如果团队是跨国团队怎么办？

所以，相比

#+begin_example
/:实体集合/:实体编号
#+end_example

我更推荐

#+begin_example
/:实体类型/:实体编号
#+end_example

这样的认知模型。

这么做我们至少可以让协议的使用者和协议的维护者统一预期，不再纠结。

API协议用在两个系统之间的“接口层”，"稳定的预期"带来的收益绝不可忽视。

很多时候,

#+begin_quote
唯一即简单。
#+end_quote

#+begin_quote
应竭尽全力消除任何形式的歧义。
#+end_quote

在每个高度聚合的团队内部的应用代码中，其实无所谓使用单数还是复数，甚至使用中文或者拼音都问题不大。
因为不管我们在API协议中不管使用单数还是复数，实际处理业务的程序代码中，我们在变量名、方法名等标识符的命名上，
从“可读性”角度出发，永远无法做到“只使用单数”或者“只使用复数”。

但是，

#+begin_quote
无论如何，我们都不应该把自身系统中不合理的设计或者小圈子内产生的妥协传播到他系统中去。
#+end_quote

#+begin_example
# Good!
/post/56/comment
/user/1341/post

# Bad!
/posts/56/comments
/users/1341/posts
#+end_example

** 一致的模式
#+begin_example
/:实体类型/:实体编号/:实体类型/:实体编号...
#+end_example

下方URL都由相同的实体类型构成，但两个URL表达的含义是不一样的。
#+begin_example
# 从所有的标签中，找到编号为456的标签，并找到拥有该标签的所有帖子。
/tag/456/post

# 从所有的帖子中，找到编号为123的帖子，并检索该帖子的所有标签。
/post/123/tag
#+end_example

我们每天都在使用的域名其实也是这种方式组织信息的。

只不过域名是从后到前缩小领域，URL是从前到后缩小领域。

#+begin_quote
news.baidu.com. 所有商业类型网站中的，百度公司的，新闻频道。
#+end_quote

希望上面这个域名语义拆解，对你有帮助。

** 不使用修饰词
如果没有这项限制，你很难阻止你的团队的成员在将来定义出
~postItems~ 、 ~postEntitis~ 、 ~commentObjects~ 等千奇百怪的命名，
最后导致合作的时候会花费大把的时间互相校对命名。

不要对资源实体对象进行修饰描述。

#+begin_example
# Good!
/user // 所有用户
/tag // 所有标签

# Evil!
/userList // List是废话
/tagItems // Items是废话
#+end_example

* Header
对于HTTP报文，Header本身即是Meta信息，例如:
~Authorization~, ~Content-Type~, ~User-Agent~ 等。

在HTTP协议中定义的标准Header之外，我们多少都需要自定义一些Header。

我们可以在[[https://www.iana.org/assignments/message-headers/message-headers.xml][IANA官方]]查看所有标准的HTTP头，
以及目前被列为提案并有可能成为标准的头。

[[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields][Wikipedia的List of HTTP header fields]]也是比较好的参考资料。

** 关于 ~X-~ 开头的Header
[[https://datatracker.ietf.org/doc/html/rfc6648][RFC6648]]中已明确废弃自定义Header以 ~X-~ 开头的推荐。

随着该RFC的普及，我们可以期待不会再产生似标准又非标准的 ~X-~ 开头的Header。

但是市面上已经有大量的软件使用了 ~X-~ ，它们成为了“事实上的标准”。

对于我们更重要的是，了解了这样的RFC产生的背景之后不再继续产生，
同时又要克制地使用这些Header。

建议任何RESTful API协议文档中，单独维护该类型的自定义Header列表。

本文档中使用的 ~X-~ 开头的Header如下。

| Header          | 值              | 含义                             |
|-----------------+-----------------+----------------------------------|
| ~X-Total-Count~ | 大于等于0的整数 | 服务端查询到的满足条件的记录总数 |
| ~X-Request-Id~  | [[https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)][UUID v4]]         | 客户端单次请求的唯一标识         |

** ~X-Total-Count~
在客户端需要展示总记录个数，总页数等场景下，需要知道记录的总数。

通过Response Header中的 ~X-Total-Count~ 字段返回该信息。

#+begin_example
X-Total-Count: 21
#+end_example

由于数据量很少，一次响应可以返回所有数据时，也可以通过“是否出现X-Total-Count字段”使客户端能够判断自己是否获取到所有数据。

** ~X-Request-Id~
客户端发起的每个请求的唯一标识。在大型系统中可以用来关联不同子系统之间的日志。监控及排查故障时大有用途。

#+begin_example
X-Request-Id: 83fbbb94-ae84-4853-bf6c-613a12bfaf32
#+end_example

* Query
** URL Encode
严格来讲应该按照[[https://datatracker.ietf.org/doc/html/rfc3986][RFC 3986]]进行编码，具体规则可以参考[[https://en.wikipedia.org/wiki/Percent-encoding][URL Encode]]。

但如果你记不住可以按照下面规则。

#+begin_quote
*值* 中如果出现英文字母和数字以外的其他字符，一律需要 ~URL Encode~ 。
#+end_quote

大多数Web框架都可以自动解码。

当前文章中，为了演示目的，不会一一进行 ~URL Encode~ 。

** 数组
*** 使用 ~repeat~ 模式
#+begin_example
/user?age=21&age=23&age=25
#+end_example

重复使用相同的字段指定不同的值来表示数组。

#+begin_quote
Why?
#+end_quote

该表达形式虽然不是最精炼的，但实际实践中问题较最少。

使用遵守[[https://datatracker.ietf.org/doc/html/rfc6570][URI Template - rfc6570]]的工具编码解码时完美兼容。

其他理由见以下几例 *不使用* 格式。

*** 不使用 ~application/x-www-form-urlencoded~

#+begin_example
/user?age[]=21&age[]=23&age[]=25
#+end_example

#+begin_quote
Why?
#+end_quote

现代主流浏览器端流行框架的解决方案中几乎全面放弃默认以该格式提交数据，
而是建议让开发者使用 ~application/json~ 。

遵守 ~OpenAPI~ 标准的 ~Swagger~ 中也不支持该格式，见[[https://swagger.io/specification/#parameter-object][参数对象]]一节。

如果你希望团队的API协议通过Swagger等工具变成在线可查的文档，
那坚决不要使用该格式。

*** 不使用 ~comma~ 模式
#+begin_example
/user?age=21,23,25
#+end_example

#+begin_quote
Why?
#+end_quote

值部分可能会出现包含 ~,~ 逗号或 ~&~ 与号的内容。

虽然这部分可以通过 ~URL Encode~ 解决，但事情并没有那么简单。

包括 ~Spring~ 在内的诸多服务端Web框架为了开发者便利会自动
~URL Decode~ ，服务端工程师会获取到有别于客户端意图的数据。

除非客户端和服务端工程师通过协商两次 ~URL Encode~ 来规避这个问题，
但两次 ~URL Encode~ 在双方都会增加额外成本。

因为它们都需要特殊对待。

** 过滤 - 比较运算符
| 符号 | 含义                 |
|------+----------------------|
| ~=~  | 等于                 |
| ~!=~ | 不等于               |
| ~>=~ | 大于等于             |
| ~<=~ | 小于等于             |
| ~%=~ | 模糊匹配（前缀匹配） |

#+begin_example
GET /user?age>=25&age<=31&job!=writer&sex=male&name%=Mike
#+end_example

#+begin_quote
为什么没有“ *大于，小于，前后模糊* ”等？
#+end_quote

网络上也确实能够找到利用例如 ~eq~, ~ne~, ~lt~, ~le~, ~gt~, ~ge~
等保留字来描述“ *等于、不等于、小于、小于等于、大于、大于等于* ”的方案。

其实希望通过 ~query~ 参数构造这般复杂的查询条件时，
你的查询条件很有可能变得进一步复杂。

以上列举的仅仅是比较运算符，除了这些，
或许你还需要定义逻辑运算符或如 ~in~ 等关系运算符。

当问题域的确扩展到这个地步的时候，相比在 ~query~ 参数上做文章，
实现适用于 ~query~ 的 ~DSL~ 可能更佳划算。

但上升到 ~DSL~ ，我们就需要考虑它的完备性，甚至它有可能需要等价于 ~SQL~ 。
定义是一方面，还需要解决解析层面的实现以及使用成本。

如果你天真地相信其他工程师愿意学习和使用半成品的 ~DSL~ ，
那么你极有可能低估了其他“ *工程师的洁癖和对通用标准的向往* ”。

#+begin_quote
在实际软件工程实践中，我们永远在利用有限的资源，去解决有限的问题，而不是不计代价地去解决所有的假想问题。
#+end_quote

如果你仍然纠结上方表格中“ *只有大于等于，没有大于* ”的问题，
不妨试着用以下方法多定义几个 ~Meta~ 字段。

#+begin_example
?[ `$eq` | `$ne`| `$lt` | `$le` | `$gt` | `$ge` ].{field}={value}&...
#+end_example

例如
#+begin_example
GET /user?$gt.age=21&$ne.age=25&$lt.age<=31&$ne.job=writer&sex=male
#+end_example

** 排序 - ~$sort~
| 参数    | 值                                                         |
|---------+------------------------------------------------------------|
| ~$sort~ | 英文 ~,~ 分割，默认正序，英文 ~-~ 倒序。顺序影响排序结果。 |

#+begin_example
GET /user?$sort=-age,sex,-job
#+end_example

** 搜索 - ~$keyword~
有一些检索场景是没有办法明确指定具体字段，甚至是实体资源类型。

例如，检索标题、摘要或者内容中包含某种关键词的所有帖子的场景。
（无法事先知道匹配哪个字段）

#+begin_example
GET /post?$keyword=网络防火墙
#+end_example

再比如，检索包含某种关键词的所有多媒体（图像、音频、视频等）。
（无法事先知道匹配哪个类型的实体）

#+begin_example
GET /media?$keyword=加菲猫
#+end_example

由于关键词也有可能包含特殊符号，
因此希望支持数组时最好也使用[[#value_array][数组]]一节中的规则。

#+begin_example
GET /media?$keyword=加菲猫&$keyword=拉布拉多
#+end_example

正常来讲，这种场景一般是在服务端搜索引擎方案下完成分词和检索操作。

** 分页 - ~$page~ 和 ~$count~ （推荐）
| 参数     | 值     | 含义                   | 默认值   |
|----------+--------+------------------------+----------|
| ~$page~  | 正整数 | 页码                   | 1        |
| ~$count~ | 正整数 | 单次可查询的最大记录数 | 协商确定 |

客户端未给定 ~$page~ 参数时，服务端按照默认值处理（必须）。

也可与客户端协商 ~$page~ 不可为空，如果为空以 ~400~ 的异常响应请求（可选）。

不管客户端是否给定 ~$count~ ，服务端无论如何都要设定合理的默认值（必须）。

~$count~ 的取值过大，会导致服务端处理的单个请求时内存占用过大，
即使服务端能够处理，网络传输也有可能成为瓶颈点，或客户端无法处理。

服务端从技术实现上，也不应该假设所有客户端都是“ *合法的* ”客户端。

对于“合法的”客户端而言，一旦服务端确定下来该最大值，
它就可以根据实际情况在不超过最大值的前提下灵活改变 ~$count~ 的取值。

目前由用户自己指定每页记录数的用户界面实现也比较常见。

出现该请求参数的组合时，服务端通常需要同时返回 ~X-Total-Count~ 。

** 分页 - ~$offset~ 和 ~$limit~
| 参数      | 值              | 含义                   | 默认值   |
|-----------+-----------------+------------------------+----------|
| ~$offset~ | 大于等于0的整数 | 偏移量。               | 0        |
| ~$limit~  | 正整数          | 单次可查询的最大记录数 | 协商确定 |

该组合与 ~$page~ 和 ~$count~ 的组合完全等价，可相互无损转换。

区别只是相比 ~$page~ 和 ~$count~ ，没那么讲“人话”，但更偏向数据库的原始语义。

同样，需要同时返回 ~X-Total-Count~ 。

** 分页 - ~$cursor~ 和 ~$count~
| 参数                           | 值     | 含义                               | 默认值           |
|--------------------------------+--------+------------------------------------+------------------|
| ~$cursor~ 或 ~$cursor.{field}~ | 正整数 | 上一个集合中，最后一个记录的唯一键 | 无该参数，或为空 |
| ~$count~ 或 ~$limit~           | 正整数 | 单次可查询的最大记录数             | 协商确定         |

在数据量过大的系统中，
服务端极有可能无法根据请求中的查询条件向客户端返回 ~X-Total-Count~ 。

通常在使用关系型数据库的情况下，由于排序和获取子集的计算是数据库系统中完成。

~X-Total-Count~ 的信息是需要多查询一次数据库才能获取到，
并且是性能损耗非常大的操作。

这一看似简单的操作，在数据规模超过一定量级之后，
从性能损耗和查询时长的角度来看，会变得不可能。

这样数据规模的系统，如果同时还具有数据更新非常活跃的特征。

“ *某种特征的数据集合的精确总数* ”有可能是上百万、上千万，
甚至，上亿为基础的数据以每秒数万、数十万个的速率发生变化的数值。

我们哪怕能够通过技术手段做到符合某种特征的数据集合没那么实时精确，
把不同特征组合数及相应的技术成本放在一起考虑的的时候，
也很快会发现这样做明显是投入产出不成比例的亏本买卖。

在超过一定数量级之后，实时精确的“ *总数* ”，
对用户也没有小数量级时那么有参考价值。

为了方便理解，在这里使用少量模拟的数据进行说明。

~$cursor~ 表示第二次查询的游标位置。

| ~$cursor.id~ |  Id | Name     | Age | Sex |
|--------------+-----+----------+-----+-----|
|              |  35 | XiaoMing |  36 | M   |
|              |  23 | ZhangSan |  33 | M   |
|              |   5 | LiSi     |  31 | M   |
|              |  27 | SunQi    |  31 | F   |
| -->          |  67 | ZhaoLiu  |  29 | M   |
|              |  17 | MeiMei   |  26 | F   |
|              |  29 | ZhengShi |  24 | M   |
|              |  31 | ZhouBa   |  24 | F   |
|              |  19 | WangWu   |  22 | F   |
|              |  41 | MeiMei   |  19 | F   |
| ...          | ... | ...      | ... | ... |

假设客户端为了获取以上集合，第一次查询通过如下参数请求，获取前5个。
#+begin_example
# 年龄倒序，性别正序（M-F），最多一次取5个。
# 该请求查询Id为35, 23, 5, 27, 67的记录。
/person?$sort=-age&$sort=sex&$count=5
#+end_example

客户端在首次查询之后，由于尚未获得游标之后记录的信息，
也就是Id为17的记录以及之后的记录，
因此无法告知服务端下一次查询应该从Id为17的记录开始查询，
只能告知服务端相同查询条件下，上一次查询游标截止的位置。

那么，第二次请求中客户端通过如下参数获得后续的数据集。
#+begin_example
/person?$sort=-age&$sort=sex&$count=5$cursor.id=67
#+end_example

这时，服务端根据排序规则和游标信息，可查询第二次查询对应的5条记录。

#+begin_src sql
SELECT t.*, c.*
FROM person t 
CROSS JOIN (SELECT * FROM person WHERE id = 67) c
WHERE (
    t.age < c.age
) OR (
    t.age = c.age AND t.sex < c.sex
) OR (
    t.age = c.age AND t.sex = t.sex AND t.id <= c.id
)
ORDER BY t.age DESC, t.sex DESC, t.id DESC
LIMIT 1, 5
#+end_src

如果数据集可以提供唯一ID，可以不为 ~$cursor~ 指定字段名。

#+begin_example
/person?$sort=-age&$sort=sex&$count=5$cursor=67
#+end_example

当数据集并不包含唯一ID字段时，
我们不得不使用多个字段的组合来确定记录的“ *唯一键* ”，
这时我们无论如何都要向服务端提供构成“唯一键”的字段信息。

例如
#+begin_example
/person?$sort=-age&$sort=sex&$count=5$cursor.age=29&$cursor.sex=M&$cursor.name=ZhaoLiu
#+end_example

当然，这种情况下数据库查询语句也需要相应地进行修改。

所以，比较推荐 ~$cursor~ 始终以 ~$cursor.{字段名}~ 格式传递信息，保持一致性。

除此之外，在这种场景下，客户端如果有用户界面，
那么它的分页查询的形式很有可能是点击“加载更多”按钮，或者滚动加载的形式。

这时，尽管客户端不再需要精确的 ~X-Total-Count~ 的信息，
但仍然需要知道“是否有更多”。

虽然我们也可以允许例如 ~X-Has-More~ 这样的自定义头，
但尽最大努力不增加非标准的自定义头的原则的角度，
我们完全可以利用 ~X-Total-Count~ 头来达到相同的效果。

因为客户端只是想知道“ *是否有更多* ”，所以服务端和客户端完全可以协商，
一旦有更多数据就保证响应头中的 ~X-Total-Count~ 大于0（例如1）
或者大于 ~$count~ 值（例如 ~$count + 1~ ）来表达 ~X-Has-More~ 的含义。

* 状态码
[[https://tools.ietf.org/html/rfc2616][HTTP1.1]]一共定义了如下的状态码，总共41个。

| 系列  | 含义       | 取值范围 | 个数 |
|-------+------------+----------+------|
| ~1xx~ | 信息       |  100-101 | 2个  |
| ~2xx~ | 成功       |  200-206 | 7个  |
| ~3xx~ | 重定向     |  300-307 | 8个  |
| ~4xx~ | 客户端错误 |  400-417 | 18个 |
| ~5xx~ | 服务端错误 |  500-505 | 6个  |

如果计划遵守 ~http1.1~ 协议,
最好不要使用 ~422~ 等其他协议规范中定义的状态吗，
兼容性会得到最大保障。

使用标准化的状态码你至少会在以下几个方面收益。

#+begin_quote
1. 业界通用标准是成本最低的沟通手段。
2. 程序设计上更容易进行抽象和分治，通过 *AOP* 等设计模式可以让代码更简洁。
3. 反应真实情况的WEB服务日志，让你的监控和统计会变的更加轻松愉快。
#+end_quote

大部分RESTful风格的API并不需要使用这么多的状态码。

WEB服务器或框架会帮助我们处理一部分，但不会处理全部，
服务端和客户端多少都有一定的实现成本。

需要根据实际需求实现，也正因为不会在所有Endpoint上实现全部，
所以一定需要协议说明文档。

比较常用的如下。

| Code | 默认返回文本       | 说明                                                                                            |
|------+--------------------+-------------------------------------------------------------------------------------------------|
|  200 | OK                 | 可以代表其他成功状态。                                                                          |
|  201 | Created            | 注意区分这个“创建成功”和下一个202的“提交成功”。                                                 |
|  202 | Accepted           | 异步或事件驱动方式的系统中非常有用。比如支付请求提交成功。                                      |
|  204 | No Content         | 除了删除，其他情况一般都应该返回Body。                                                          |
|  302 | Found              | 临时重定向，经常用来应对会话超时。但如果想遵守严格的http1.1协议，你应该使用307。                |
|  307 | Temporary Redirect | 见302                                                                                           |
|  304 | Not Modified       | 对于调用频率非常高，应用了服务端缓存技术的API来讲要使用此状态码告知客户端使用的是缓存中的数据。 |
|  400 | Bad Request        | 可以代表其他。见[[#异常][异常]]                                                                            |
|  401 | Unauthorized       | 身份验证未通过。                                                                                |
|  403 | Forbidden          | 权限验证未通过。                                                                                |
|  404 | Not found          | 请求的资源不存在。                                                                              |
|  409 | Conflict           | 资源冲突。                                                                                      |

永远不要在发生服务端异常的时候，假装没有发生服务端异常，
用 ~2XX~, ~4XX~ 系列状态码响应客户端。

客户端自然拥有关于请求的所有知识，如果确实发生了客户端错误，
用户结合客户端相应的提示知道如何“ *修正* ”这样的错误，
或者客户端能够引导用户如何才能从“错误”中得到“ *解救* ”。
但如果在发生服务端异常的时候，响应了 ~2XX~ ， ~4XX~ ，
客户端由于不掌握关于服务端实现细节的知识，将会完全不知道该如何处理这样的异常。

客户端一般会直接面向终端用户，而用户并不关心服务端到底是数据库发生异常，
还是机房之间的网络设备发生故障，还是文件系统已经达到存储上限。
即便客户端根据状态码在技术实现层面能够判断出大概，
也只能给用户展示“ *服务繁忙* ”，“ *网络异常* ”等笼统的信息。
再则客户端程序代码中需要包含大量应付服务端实现细节的内容，
本身也不符合“ *尽量向上一层屏蔽它所不关心的内部实现细节* ”的分层原则。
向客户端暴露过多能够猜测服务端实现细节的信息，从安全角度也存在隐患。

#+begin_quote
永远不要返回 *5XX* ！
这是向所有客户端广播“ *我的架构方案很糟糕！我的服务运维能力极差！* ”的行为。
#+end_quote

客户端是否实现友好的 ~5XX~ 的用户界面，
不应该成为服务端是否可以返回 ~5XX~ 异常的决策依据。

~5XX~ 的界面无论多么友好，它们终究是迫不得已的“ *应付* ”。

客户端也好，用户也好，面对这种异常无论如何都无法自行解决。

网络、CPU、内存、磁盘天然哪个都有可能成为瓶颈和故障点。

我们应该通过充分了解自身服务的稳定性、性能瓶颈，完善监控和灾备方案，不断提升架构的健壮性来达到“ *不响应5XX* ”的目的，
而不是“ *假装成功* ”，“ *甩锅* ” 或 “ *踢皮球* ”。

实事求是地响应 ~5XX~ ，实事求是地记录日志，在前期查缺补漏、完善监控，
找到并加固整体系统的脆弱点有很重要的意义。

* 异常
** 401 - 身份验证未通过
#+begin_example
Status Code: 401 Unauthorized
#+end_example

很多年前以网站多以服务端渲染为主，当Cookie或Session建立的会话失效时，会通过3XX响应重定向浏览器访问登录界面。

如今，越来越多的Web应用使用异步请求完成登录的操作，不再依赖服务端来完成此类重定向。

因为Javascript没有权限读取 ~3XX~ 响应中的 ~Location~ ，
所以浏览器应用也无法使浏览器访问（浏览器地址栏变成）
~Location~ 头中指定的地址。

同时，现代的Web前端应用多数都会使用前端路由，而不是服务端路由。

这意味着服务端不再需要，从分工和职责边界的角度来看，
也不应掌握关于前端路由表相关的设计细节。

（前端路由表指的是浏览器地址栏中出现的地址的路由表，并非API地址的路由表）

在变更比较频繁的应用中，更是如此。

从服务端开发者的角度，
始终及时维护时刻变化但自身又完全用不着的前端路由信息非常不合理。

从浏览器端开发者的角度，每次变更路由信息，
都需要带上服务端的开发人员一起修改代码，也会大大降低开发效率。

因此，在使用的前端路由技术的Web应用中，如果条件允许，
应尽可能把身份验证未通过时的 ~3XX~ 重定向的实现修改为 ~401~ 的响应。

如果创建会话（登陆）的API的地址为动态的，
或者不希望前端应用代码中硬编码该地址，可以使用 ~Location~ 返回该地址。

#+begin_example
Status Code: 401 Unauthorized
Location: /login
#+end_example

** 403 - 权限验证未通过
#+begin_example
Status Code: 401 Unauthorized
#+end_example

- ~Authorize~ 一般指对特定的资源授予权限的行为。
- ~Authenticate~ 一般指授予特定身份的行为。

在一个系统中拥有某一种身份，不等同于对该系统中任何资源都有访问权限。

这像你是学生可以进入学校，可以进入教室，但是你不能到校长办公室自习。

相比 ~401~ 表示“身份验证”未通过，
~403~ 的响应表示“ *身份验证* ”可能通过并且服务端也能够识别请求，
但是因为 *权限不足* 拒绝客户端获取资源。

** 404 - 资源不存在
#+begin_example
Status Code: 404 Not Found
#+end_example

** 409 - 资源冲突
#+begin_example
Status Code: 409 Conflict
#+end_example

~PUT~ 原本用来完成“替换”的操作，
但也有不少应用会用 ~PUT~ 来创建路径事先确定的对象
（例如图片、视频、压缩文件等）， 这时如果资源已被创建，
就会用 ~409~ 响应客户端，表示资源已存在无法覆盖。

除此之外，实体数据的多个字段构成“ *唯一键* ”的情况下，
~POST~ 来创建新对象也有可能产生冲突，此时也可以使用 ~409~ 。

~409~ 响应时，
一般是比较明确客户端可以通过变更部分请求内容重新请求来“ *修复* ”这样的冲突。

如果客户端仅靠 ~409~ 状态码来修正冲突，推荐使用 ~400~ 来响应，
并且通过 ~Body~ 告知客户端冲突的原因或细节。

** 400 - 其他客户端异常
凡是需要具体内容才能够描述清楚的客户端异常应该都使用 ~400~ 响应，
并且 ~Body~ 按照如下格式。
#+begin_example
{
    "code": "E611", # 可枚举的错误码，类型和值均可以通过协商定义
    "msg": "Form fields vailidation is failed.",
    "field": [ # 可选。描述出现异常的具体字段。
        {
            "key": ["password"], # 表示请求中字段位置的key(json)的数组
            "msg": "Password is too short."
        },
        {
            "key": ["mobile"],
            "msg": "The phone number you entered is not valid."
        }
        {
            "key": ["contact", "email"],
            "msg": "Email address can not be longger than {length} characters.",
            # 可选。通过这种方式可以与国际化方案结合，此时msg为msgid，客户端与服务端共享该msgid信息。
            "vars": {
                length: 100,
            }
        },
        {
            "key": ["contact", "email"], # 相同的key出现多个异常时，采用平铺方式而不是嵌套数组方式。
            "msg": "Email address can only contain {allowed}.",
            "vars": {
                allowed: "letters (a-z), numbers (0-9), and periods (.), and @",
            }
        },
    ]
}
#+end_example

* Body
** 增
相当于SQL中的INSERT。

创建对象的时候“ID、用户、是否删除、创建时间”等特殊的属性，需要由服务端生成。

这意味着客户端在提交时刻，并不掌握新增实体的所有信息。

所以，需要返回新创建的实体的完整内容，默认返回《元实体》。

#+begin_example
# 请求
# POST /post
{
    "title": "合理设计RESTful API",
    "category": "14",
    "content": "..... ...... ......",
}

# 响应
# Status Code: 201 Created
{
    "id": "1234513432",
    "title": "合理设计RESTful API",
    "category": "14",
    "author": "23",
    "content": "..... ...... ......",
    "deleted": false,
    "ctime": "2024-08-23T21:43:21Z",
    "utime": "2025-03-15T12:07:59Z",
}
#+end_example

** 删
** 替
** 改
** 查
* 版本化
使用[[https://semver.org/][Semantic Versioning]]。

版本化会为新旧并存、无损重构、平滑升级、请求分发、流量控制等创造很多便利条件，
同时也为API的用户提供方便。

在 ~Path~ 中包含 ~MAJOR~ 位来表示协议架构或 ~Schema~ 层面的版本。

该版本为协议架构，而非应用程序的架构，程序架构升级和API协议结构并不是一回事。

例如，改变了身份验证、权限验证方式，废弃了一些用户已经在使用的 ~Header~ ，
改变了 ~Body~ 的基本结构等向后不兼容的变更为协议架构层面。

这种改变的特点是会影响所有或者很大一部分既有的API调用，
这时应该在另一个 ~MAJOR~ 版本路径上部署新的API。

#+begin_example
/rest/v1/...
/api/v3/...
#+end_example

在 ~Query~ 中用 ~$ver~ 参数指定完整版本，未包含时始终调用最新版本。

#+begin_example
/rest/v1/posts/123?$ver=v1.1.0
/rest/v1/posts/123?$ver=v1.1.5
#+end_example

* TODO
:PROPERTIES:
:CUSTOM_ID: todo
:END:
https://hanzhixing.gitbooks.io/better-restful-api-design/
