#+title: 优秀编码原则

* 可读性
** 面向人类编程，而不是计算机
任何软件都是有生命的，没有一款软件是由一个人独自编写，并且能能保证永生的。

软件产品只有被越来越多的人使用或修改更新才会有活力。

可读性的权重再怎么强调也不为过，只有可读，才更容易被修复改善。

绝大多数的代码，往往都是写给未来半年、一年，甚至更长时间之后的自己。

那个将来，已经记忆模糊的你，是否会有信心非常轻松地读懂眼前的代码？

** 命名是计算机科学里最困难的事情之一
#+begin_quote
There are only two hard things in Computer Science: cache invalidation and naming things.
#+end_quote

[[https://martinfowler.com/][Martin Fowler]]在自己的[[https://martinfowler.com/bliki/TwoHardThings.html][TwoHardThings]]博文中整理了相关“语录”。

从精力分配的角度来说，我们也应该把更多精力投入到更困难的事情上。

#+begin_quote
在软件开发领域，命名意味着很多。
#+end_quote

* [[https://en.wikipedia.org/wiki/SOLID][SOLID原则]]

它起初是在面向对象编程的语境下被提出的。

但是真正理解它的意义之后，你会发现

#+begin_quote
SOLID原则同样适用于变量、函数、类、文件、模块、分层、微服务、
子系统、乃至产品......
#+end_quote

《单一职责、开放-封闭》为最终目的，
《里氏替换、接口隔离、依赖倒置》则是关键路径和方法。

** 单一职责(*S*)

它是一切的基础。

认真去思考所谓《边界》。

只有懂得清晰的《边界》在哪里，

才能够更好地命名，让他人清晰地理解设计意图，

才能够编写出足够独立和可复用的代码。

** 开放-封闭(*O*)

面向扩展开放，面向修改封闭。

在函数式编程中，甚至变量都不允许被修改。

它让你有了再次检验是否遵守了《单一职责》原则的机会。

#+begin_quote
如果你为了修改一个功能，同时打开许多文件，
每个文件中都修改一点，那么是时候该好好反思了。
#+end_quote

** 里氏替换(*L*)

面向抽象编程，而不是具体实现。

它是许多协议、标准、规范得以成功的底层逻辑之一。

** 接口隔离(*I*)

监督你是否遵守了《单一职责、开放-封闭》原则。

** 依赖倒置(*D*)

与“里氏替换”形成互补。

* 不要写注释
** 少即是多
著名的德国现代主义建筑大师密斯·凡·德·罗（[[https://en.wikipedia.org/wiki/Ludwig_Mies_van_der_Rohe][Ludwig
Mies van der Rohe]]）曾经留下“Less is more”的名言。

#+begin_quote
“他的设计作品中各个细部精简到不可精简的绝对境界，不少作品结构几乎完全暴露，但是它们高贵、雅致，已使结构本身升华为建筑艺术。”
#+end_quote

不写注释绝不仅仅是不写几行文字这么简单。

想要代码无注释，还能简单易懂，就需要修炼真正掌控代码的能力。

其中，命名是重中之重，它关乎你如何精准抽象事物。

优雅的代码应该像自然语言一样通俗易懂。

#+begin_quote
通过拆分代码、重命名函数、变量等重构手段，能否让代码更容易被读懂？
#+end_quote

** 不要愚蠢地使用两种语言描述相同的事情

#+begin_src js
/**
 ,* 两数相加
 ,*
 ,* @param {number} a
 ,* @param {number} b
 ,* @returns {number}
 ,*/
function add(a, b) {
    return a + b;
}
#+end_src

对比

#+begin_src js
function add(a, b) {
    return a + b;
}
#+end_src

并不会增加多少帮助理解代码的内容。

*** 自动生成文档？

- 受众是谁？
- 不允许看源代码吗？
- 代码编辑器无法提示类型吗？
- 是公共接口吗？
- 只看注释生成的文档会用吗？
- 不需要说明使用背景吗？
- 不需要实例说明吗？
- 还额外需要写帮助文档吗？
- 你上一次阅读注释自动生成的文档是什么时候？
- 是不是在解决实际不会存在的假想问题？

** 不要妄想通过注释让代码更容易被理解
通过注释阐述代码逻辑的行为，会在潜意识里促使我们编写更加随意的代码。

把注释当作退路的这种懒惰，会让我们错失很多绝佳的重构时机。

最终代码会从结构上、语意上，变得更加难以理解。

就复杂算法而言，即便代码写的再好，没有理论背书，通常也难被读懂。

这类代码通常写一次之后会很少改动。

与其在注释里写它们的逻辑，不如通过注释告知阅读者需要掌握哪些理论知识。

** 注释极有可能会过时
一旦用注释来表达与代码接近的含义，
每次修改代码的时候你都需要阅读注释，并同步修改。

将来不一致的代码和注释，会让阅读者产生不必要的困惑。

当阅读者发现注释与代码不一致时，因为真正被运行的是代码，所以他们一定会以代码为准。

他们从此会不再关心那些注释。

既然不会关心，那些注释就没必要存在。


** 不要通过注释“移除”僵尸代码
具有“移除僵尸代码”功能的注释，一定会导致代码阅读者去思考

#+begin_quote
为什么这段代码被注释了？
#+end_quote

直接删掉！

=Git, SVN, Mercurial= 等版本控制软件都可以用来查看历史版本。

** 注释只回答“为什么”的问题
#+begin_quote
让代码回答“什么”和“怎么样”的问题，注释只回答“为什么”的问题。
#+end_quote

- 为什么这里有注释？
- 为什么注释里有这些信息？

多用关键词进行标注。

- TODO: 待实现。
- HACK: 非正常方式的实现。
- FIXME: 有隐患，不修正会引发问题。
- REVIEW: 未经深思熟虑、匆忙实现、测试不完全。
- NOTE: 为什么代码实现是现在这个样子。
- DEPRECATED: 下一个版本会直接删除。
- BUG: 存在尚未修复缺陷。
- XXX: 这个关键词还是别用了。

** 强制要求写注释？

如果你在工作环境中

- 被强制要求写注释
- 强制遵守特有的写注释规则
- 甚至被强制要求注释占比

那么赶紧换个工作吧，你正在和一群呆瓜一起工作！

差的工程师始终是差的，我们没有办法通过这样的规则，让一个差的工程师变得足够优秀。


