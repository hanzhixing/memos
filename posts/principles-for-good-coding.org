[[../README.md][返回首页]]

* 优秀编码原则
:PROPERTIES:
:CUSTOM_ID: 优秀编码原则
:END:

#+begin_quote
只有一个原则: 不要写注释
#+end_quote

** 命名
*** 面向人类编程，而不是计算机
:PROPERTIES:
:CUSTOM_ID: 面向人类编程而不是计算机
:END:
任何软件都是有生命的，没有一个软件是一个人独自编写，然后天然能够确保它永生。

软件产品只有被越来越多的人使用才会有生命。

随着发展更新换代的代码，总有一天会被其他人阅读和修改，甚至会有更多的人参与进来，使它保持充满活力。

可读性的权重再怎么强调也不为过，只有可读，才可以更容易被修复缺陷，才可以更容易进行性能优化。

更值得记住的是，绝大多数的代码，往往都是写给未来的你自己，或许是半年后的你，或许是一年之后的你，甚至有可能是五年之后的你。

未来，已经记忆模糊的你，是否会有信心非常轻松地读懂眼前你正在看到的代码？

#+begin_quote
不要妄想通过注释来让代码更容易理解。
#+end_quote

*** 命名是计算机科学里最困难的事情之一
:PROPERTIES:
:CUSTOM_ID: 命名是计算机科学里最困难的事情之一
:END:
[[https://www.karlton.org/karlton/][Phil Karlton]]曾经说过

#+begin_quote
There are only two hard things in Computer Science: cache invalidation
and naming things.
#+end_quote

[[https://martinfowler.com/][Martin
Fowler]]在自己的博客[[https://martinfowler.com/bliki/TwoHardThings.html][TwoHardThings]]中也在维护一个相关“语录”。

我们需要接受一个事实。

#+begin_quote
命名是计算机科学里最困难的事情之一。
#+end_quote

从精力分配的角度来说，我们也应该把更多精力投入到更困难的事情上。

软件领域命名意味着很多。

*** SOLID原则
:PROPERTIES:
:CUSTOM_ID: solid原则
:END:
[[https://en.wikipedia.org/wiki/SOLID][SOLID原则]]起初是以面向对象编程作为背景提出的。
但是它适用于广泛适用于不同的计算机技术。

**** 单一职责(S)
:PROPERTIES:
:CUSTOM_ID: 单一职责s
:END:
适用于变量、函数、类、文件、模块、分层、微服务、子系统、乃至产品......

单一职责原则在心，你才会真正认真去思考所谓“边界”，只有懂得清晰的边界在哪里，你才能够编写出足够独立和足够可复用的代码。进一步你才能够更好地命名它们，并且帮助他人清晰地理解它们设计意图。

单一职责原则可以让写代码的过程像搭积木一样愉快和灵活，它是一切的基础。

**** 开放-封闭(O)
:PROPERTIES:
:CUSTOM_ID: 开放-封闭o
:END:
面向扩展开放，面向修改封闭。

同样适用于变量、函数、类、文件、模块、分层、微服务、子系统、乃至产品......

没错，即便是变量，也可以应用该原则，在函数式编程中尤其重要，甚至有一些语言中甚至在语言层面阻止你修改变量。

而检查自己的设计是否符合该原则，也是再一次检验是否遵守了“单一职责”原则的机会。

开放-封闭原则，也会让代码的更新更加轻松，大大降低持续维护的成本。

如果你在修改某一功能的时候，经常在IDE或者编辑器中打开许多文件，并且每个文件中都修改一点点，那么是时候好好反思了。

**** 里氏替换(L)
:PROPERTIES:
:CUSTOM_ID: 里氏替换l
:END:
该原则可以监督你面向抽象编程，而不是具体实现。

它也是许多协议、标准、规范得以成功的底层逻辑之一。

目前你在市面上可以买到的吸尘器都会标配很多种吸头。你可以任意换装不同的吸头的原因正是因为吸尘器主机主要抽象了“吸空气”的行为。

可以通过求解长方形面积的函数来求得正方形的面积，也是因为这样的函数抽象了通过长宽计算乘积的行为。

**** 接口隔离(I)
:PROPERTIES:
:CUSTOM_ID: 接口隔离i
:END:
该原则可以监督你是否很好地遵守了“单一职责”和“开放-封闭”原则，反过来它也可以辅助你更好的遵守这两个原则。

尽量让使用者组合多个相对独立的单一职责的功能，而不是为了显现自己全能，让使用者去学习和对接它本不需要关心的事情。

**** 依赖倒置(D)
:PROPERTIES:
:CUSTOM_ID: 依赖倒置d
:END:
与“里氏替换”形成互补，被组合的代码都应该“面向抽象编程，而不是具体实现”。

同样也是许多协议、标准、规范得以成功的底层逻辑之一。

*** 面向扩展开放，面向修改封闭
:PROPERTIES:
:CUSTOM_ID: 面向扩展开放面向修改封闭
:END:
*** 少即是多
:PROPERTIES:
:CUSTOM_ID: 少即是多
:END:
著名的德国现代主义建筑大师密斯·凡·德·罗（[[https://en.wikipedia.org/wiki/Ludwig_Mies_van_der_Rohe][Ludwig
Mies van der Rohe]]）曾经留下“Less is more”的名言。

《他的设计作品中各个细部精简到不可精简的绝对境界，不少作品结构几乎完全暴露，但是它们高贵、雅致，已使结构本身升华为建筑艺术。》

不写注释绝不是你所想的仅仅是不写上去那几行文字这么简单。

没有注释的情况下，代码还能够达到简单易懂的境界，你需要真正修炼掌控代码的能力。

其中，命名是重中之重，它关乎你如何精准抽象事物。

*** 让代码回答“什么”和“怎么样”的问题，注释只回答“为什么”的问题
:PROPERTIES:
:CUSTOM_ID: 让代码回答什么和怎么样的问题注释只回答为什么的问题
:END:
少即是多

#+begin_quote
规则一：只有在代码不容易阅读的时候，才写注释。
#+end_quote

#+begin_quote
规则二：没有注释的时候，代码首先要容易阅读。
#+end_quote

当你发现需要写注释的时候，也意味着没有做到第二条规则，这个时候应该问自己“通过重命名函数，重命名变量，能否让代码变得更容易读懂？”

优秀的程序员阅读代码应该像阅读自然语言一样，所以不要愚蠢地使用两种语言描述相同的事情。

#+begin_src js
/**
 ,* 两数相加
 ,*
 ,* @param {number} a
 ,* @param {number} b
 ,* @returns {number}
 ,*/
 function add(a, b) {
     return a + b;
 }
#+end_src

对比

#+begin_src js
 function add(a, b) {
     return a + b;
 }
#+end_src

并不增加多少帮助理解代码的内容。

*** 每个函数要足够短
:PROPERTIES:
:CUSTOM_ID: 每个函数要足够短
:END:
一个函数，加上空行和注释，最好能在一个屏幕看到全貌。研究表明通过各种跳转才能理清逻辑的代码通常会产生更多的BUG。

注释极有可能会过时，但代码不会。一旦你选择用代码和注释来表达接近的含义，每次修改代码的时候你都需要阅读注释，并同步修改。否则将来不一致的代码和注释让阅读者产生不必要的困惑。当阅读者发现注释与代码不一致，他们一定会以代码为准，因为代码是真正被运行的，他们从此不再关心那些注释，既然不会关心，那些注释就没必要在那里占着空间。

带着辅助说明代码的注视，会促使我们编写随意的代码，然后用注释来弥补这样的懒惰。最终代码会变得更加难以理解，或者组织方式上会出现问题。

不要通过注释“移除”僵尸代码，这样的注释一定会导致代码阅读者去思考“为什么这段代码被注释了？”。应该直接删掉。

用大段注释说明比较复杂的算法。因为比较复杂的算法，通常难以直观地通过阅读代码理解到，即便代码写的比较好。
另外很复杂但是运行良好的算法，通常写一次之后很少会改动，所以对这样的算法通过注释详细说明是有帮助的。

通过注释标记极有可能被搜索到的关键词，例如：BUG, FIXME, HACK, UNDONE,
TODO等等。

为文档自动生成工具写注释，非常不幸，但这是必要的。这样的注释是写给没有办法直接阅读代码的人。

通过注释描述比较难以琢磨，从代码来看不那么直观的信息。

如果有办法能够让事情变得更好，忽略以上所有规则。

如果你在一个被强制要求遵守某种公司特有写注释的规则，甚至被要求保证注释比例，那么赶紧换个工作，你正在和一群呆瓜一起工作。

差的工程师始终是差的，我们没有办法通过这样的规则，让一个差的工程师变得足够优秀。

** 不要写注释
:PROPERTIES:
:CUSTOM_ID: 不要写注释
:END:
