---
author: Zhixing Han
title: 优秀编码原则
---

# 可读性

## 面向人类编程，而不是计算机

任何软件都是有生命的，没有一个软件是一个人独自编写，然后天然能够保证它永生。

软件产品只有被越来越多的人使用或修改更新才会有活力。

=可读性=的权重再怎么强调也不为过，只有可读，才更容易被修复改善。

绝大多数的代码，往往都是写给未来半年、一年，甚至更长时间之后的自己。

在那个将来，已经记忆模糊的你，是否会有信心非常轻松地读懂眼前正在看着的代码？

## 命名是计算机科学里最困难的事情之一

[Phil Karlton](https://www.karlton.org/karlton/)曾经说过

> There are only two hard things in Computer Science: cache invalidation
> and naming things.

[Martin
Fowler](https://martinfowler.com/)在自己的博客[TwoHardThings](https://martinfowler.com/bliki/TwoHardThings.html)中也在维护一个相关“语录”。

我们需要接受一个事实。

> 命名是计算机科学里最困难的事情之一。

从精力分配的角度来说，我们也应该把更多精力投入到更困难的事情上。

软件领域命名意味着很多。

## SOLID原则

[SOLID原则](https://en.wikipedia.org/wiki/SOLID)起初是以面向对象编程作为背景提出的。
但是它适用于广泛适用于不同的计算机技术。

### 单一职责(S)

适用于变量、函数、类、文件、模块、分层、微服务、子系统、乃至产品……

单一职责原则在心，你才会真正认真去思考所谓“边界”，只有懂得清晰的边界在哪里，你才能够编写出足够独立和足够可复用的代码。进一步你才能够更好地命名它们，并且帮助他人清晰地理解它们设计意图。

单一职责原则可以让写代码的过程像搭积木一样愉快和灵活，它是一切的基础。

### 开放-封闭(O)

面向扩展开放，面向修改封闭。

同样适用于变量、函数、类、文件、模块、分层、微服务、子系统、乃至产品……

没错，即便是变量，也可以应用该原则，在函数式编程中尤其重要，甚至有一些语言中甚至在语言层面阻止你修改变量。

而检查自己的设计是否符合该原则，也是再一次检验是否遵守了“单一职责”原则的机会。

开放-封闭原则，也会让代码的更新更加轻松，大大降低持续维护的成本。

如果你在修改某一功能的时候，经常在IDE或者编辑器中打开许多文件，并且每个文件中都修改一点点，那么是时候好好反思了。

### 里氏替换(L)

该原则可以监督你面向抽象编程，而不是具体实现。

它也是许多协议、标准、规范得以成功的底层逻辑之一。

目前你在市面上可以买到的吸尘器都会标配很多种吸头。你可以任意换装不同的吸头的原因正是因为吸尘器主机主要抽象了“吸空气”的行为。

可以通过求解长方形面积的函数来求得正方形的面积，也是因为这样的函数抽象了通过长宽计算乘积的行为。

### 接口隔离(I)

该原则可以监督你是否很好地遵守了“单一职责”和“开放-封闭”原则，反过来它也可以辅助你更好的遵守这两个原则。

尽量让使用者组合多个相对独立的单一职责的功能，而不是为了显现自己全能，让使用者去学习和对接它本不需要关心的事情。

### 依赖倒置(D)

与“里氏替换”形成互补，被组合的代码都应该“面向抽象编程，而不是具体实现”。

同样也是许多协议、标准、规范得以成功的底层逻辑之一。

## 面向扩展开放，面向修改封闭

## 少即是多

著名的德国现代主义建筑大师密斯·凡·德·罗（[Ludwig Mies van der
Rohe](https://en.wikipedia.org/wiki/Ludwig_Mies_van_der_Rohe)）曾经留下“Less
is more”的名言。

《他的设计作品中各个细部精简到不可精简的绝对境界，不少作品结构几乎完全暴露，但是它们高贵、雅致，已使结构本身升华为建筑艺术。》

不写注释绝不是你所想的仅仅是不写上去那几行文字这么简单。

没有注释的情况下，代码还能够达到简单易懂的境界，你需要真正修炼掌控代码的能力。

其中，命名是重中之重，它关乎你如何精准抽象事物。

## 让代码回答“什么”和“怎么样”的问题，注释只回答“为什么”的问题

少即是多

> 规则一：只有在代码不容易阅读的时候，才写注释。

> 规则二：没有注释的时候，代码首先要容易阅读。

当你发现需要写注释的时候，也意味着没有做到第二条规则，这个时候应该问自己“通过重命名函数，重命名变量，能否让代码变得更容易读懂？”

优秀的程序员阅读代码应该像阅读自然语言一样，所以不要愚蠢地使用两种语言描述相同的事情。

``` javascript
/**
 * 两数相加
 *
 * @param {number} a
 * @param {number} b
 * @returns {number}
 */
function add(a, b) {
    return a + b;
}
```

对比

``` javascript
function add(a, b) {
    return a + b;
}
```

并不增加多少帮助理解代码的内容。

## 每个函数要足够短

一个函数，加上空行和注释，最好能在一个屏幕看到全貌。研究表明通过各种跳转才能理清逻辑的代码通常会产生更多的BUG。

注释极有可能会过时，但代码不会。一旦你选择用代码和注释来表达接近的含义，每次修改代码的时候你都需要阅读注释，并同步修改。否则将来不一致的代码和注释让阅读者产生不必要的困惑。当阅读者发现注释与代码不一致，他们一定会以代码为准，因为代码是真正被运行的，他们从此不再关心那些注释，既然不会关心，那些注释就没必要在那里占着空间。

带着辅助说明代码的注视，会促使我们编写随意的代码，然后用注释来弥补这样的懒惰。最终代码会变得更加难以理解，或者组织方式上会出现问题。

不要通过注释“移除”僵尸代码，这样的注释一定会导致代码阅读者去思考“为什么这段代码被注释了？”。应该直接删掉。

用大段注释说明比较复杂的算法。因为比较复杂的算法，通常难以直观地通过阅读代码理解到，即便代码写的比较好。
另外很复杂但是运行良好的算法，通常写一次之后很少会改动，所以对这样的算法通过注释详细说明是有帮助的。

通过注释标记极有可能被搜索到的关键词，例如：BUG, FIXME, HACK, UNDONE,
TODO等等。

为文档自动生成工具写注释，非常不幸，但这是必要的。这样的注释是写给没有办法直接阅读代码的人。

通过注释描述比较难以琢磨，从代码来看不那么直观的信息。

如果有办法能够让事情变得更好，忽略以上所有规则。

如果你在一个被强制要求遵守某种公司特有写注释的规则，甚至被要求保证注释比例，那么赶紧换个工作，你正在和一群呆瓜一起工作。

差的工程师始终是差的，我们没有办法通过这样的规则，让一个差的工程师变得足够优秀。

# 不要写注释

> 不要妄想通过注释来让代码更容易理解。
