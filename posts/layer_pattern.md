# 如何在业务实现上把网络七层协议的思路一路扩展到屏幕上

这是一个前端工程师写的，主要给前端工程师看的，但是尽量没有使用前端领域专业术语写的，一篇技术随笔。

其实我要说的不是ISO7层协议，而是分层思想的本质。

我们需要一些概念上的共识。

## 我们说范式化的时候到底在说什么？。
狭义上，最直接最常见的引用这种定义的领域是关系型数据库。

数据库的范式化很复杂，很抽象，甚至为了精准的表达，有不少文献中都用到了数学公式。

范式化在关系型数据库这一语境中，其实通俗点讲是这样的。
> 对于任何一种事物，尽一切的可能，非常努力地做到它只在一处被记录。对于它的属性，也做到只在一处记录。如果需要记录关联关系，那也尽一切的可能，非常努力地使用尽可能少的信息来记录。

为什么做这种事情呢？
因为在多处记录相同信息的时候，进行信息同步，保持它们之间的一致性实在是太困难了。同步，我们往往要把时间要素也考虑进去，“在什么时刻先更新哪一处？”是很要命的问题，因为你“先更新哪一处可能都是错的”。如果你不认同，那对不起，我错了，慢走不送。但请相信我，同步问题绝对是计算机科学中，最难解决的问题，它往往比我们能想象到的情况要复杂得多。你可能还没遇到让你的方案出丑的场景。

范式化对应的英语单词是normalize。
广义上，单从英文词汇字面含义上，它碰巧还可以表达正常化、标准化。

不就是设计字段吗？
扯这么多干嘛？
怎么还说我不正常了呢？

如果你脑中此时此刻飘过各种不适，别急。

数据库语境中的范式化虽然不是它的初衷，但以它特有的方式教育、训练着我们做一件事情。

> 减少信息量，有限、唯一、不变的方式管理这些信息。

## 那当我们说分层的时候到底在说什么？

网络7层协议，除非你是对硬件、驱动程序、操作系统内核进行特殊的编程，否则应该是不太会直接去操作机器码或汇编。

至少在Linux中，内核层面向程序员暴露的信息项是极少的。尽管也不算是屈指可数的量级，但和我们日常要处理的实际业务中的信息项的数量级相比，少的够可以了。Linux也是一路用一切皆文件的思想和口号让我们更容易理解它、学习它的工作方式。

> 信息量足够少，管理信息的手段有限、不变。

从硬件那一层，从底到上，一路走到内核这一层，至少是做到了这一点。所以到这儿，工业化程度已经是非常高的水平了。

应用层我们与内核打交道，可能会涉及到的信息项大致有这些。
- 文件描述符
- 文件类型
- 标准输入
- 标准输出
- 标准错误
- 以字节码描述的内容
- 内容的长度
- 打开
- 关闭
- 读取
- 写入
- 硬盘IO方式
- 描述文件中位置的指针

但是，更往上，越往上越惨不忍睹。

层出不穷的概念，定义不明确、模棱两可的概念一路膨胀到屏幕。

到屏幕这里，居然会有“面包屑、组合拳盒子”这种匪夷所思的词汇出现。甚至会看到魔兽世界、Dota、希腊神话等不同次元世界中的人物出现。
😱😰😭

没办法，这是现实，我们的世界正式如此的复杂。

这也暴露了计算机科学里边第二大难题“命名问题”。

## 从操作系统内核往上开始，我们需要一路同时解决两大难题——同步、命名。

标题既然是“如何”，如果你本来期待看到第一步做什么，第二步做什么，那非常抱歉，我只能很遗憾地告诉你，我也不知道。你在这一段往下也无法看到关于第一步第二步的内容。至少在操作层面，层分到这儿，还没有好懂的说明书可以看。

但是，如果想达到低层那种工业化水平和效率，我们最好能够理解我们面对什么样的问题，它们有多难，难在哪。涉及到层，我们需要非常刻意地，非常主动地去思考和交流。它们格外需要更多的精力和关注、绞尽脑汁的努力和艰辛的训练。

“网络七层协议，一切皆文件……”，它们历史上，也并不像现在那么明朗，也是通过类似艰辛的过程，一步一步变成今天这个样子的。你要明白古人为了区分“苹果”和“梨”，也是付出了心血的。有了“苹果”和“梨”，你以为已经能区分这两种水果了。但到果园转转，到水果店看看，那里有多少种不同的苹果，有多少种不同的梨。有的明明是个“小一点的西红柿”，但从某一天开始人们用了“圣女果”。你看到它们毕竟、真的就和西红柿不一样，所以你也认可了接受了。这时，你再看到那颗苹果，它还是苹果吗？叫“酸甜脆果”，“小仙果”为啥就不行吗？

所以，重点是我们想在当下语境中想要通过什么样的概括程度和区分度的概念来形成共识。

尽管范式化和分层，看上去是不一样的思路。但它们在更低层，是做一样的事情。

减少信息量，有限、唯一、不变的方式管理这些信息。

分层是一种以不变应万变的艺术，也是一层一层把抽象概念和粒度逼近真实世界的工业化的手段。

由于不同的层内，抽象的角度和粒度不一样导致的，跨层交互关系往往是交错的。但这并不是太大的问题。

你在应用程序中去访问文件系统，事实上也是如此的。你非常有可能在一个业务单元中去读取和写入不同的文件，反之一个文件也有可能被应用不同的单元读取和写入。只是它们都是文件，操作文件的方式是始终不变的。

再说一个非常核心的问题。

## 一个层内的事物是什么时刻被确定下来的？

这是最容易混淆的点。

层内的事物确定下来的时刻一定在我们定义它的边界之后，抽象这一层概念的粒度，以及行为方式的那个时间点。

这个时间点之后，这一层的内容，不会因为它的上一层的行为而发生质的改变。

很多人设计数据库的时候，以为数据表存在，是因为读取的程序希望如何如何读取，然后那个数据表才应该长成什么样。实际并不是。
> 层所暴露的事物是一个产品的边界，一个业务的边界确定下来那个时刻，建立完概念模型的时间点被确定下来的。
> 与程序怎么操作无关，与是否真的存在操作它们的程序无关，它们是因为产品和业务而形成的客观存在。

如果业务确定要涵盖权限，那就不管上层是否真正实现了权限管理功能，权限相关的抽象和概念已经产生。这同时与是否真的在物理上给硬盘真正写入关于它的信息也无关。
在这个时间节点，我们可以选择物理上实现，或者不实现，这并不那么重要。但最好你要知道这个业务范畴已经有RBAC、ABAC这种经历多年实践检验的最佳实践的存在。以便避免你以上层的实现来推导的数据表没有能力做到“以不变应万变”，后续持续地影响着上层实现，一遍又一遍的改，每次改动都是“牵一发动全身”。

到web server这个分界，很多人也认为RESTful API中的资源，是由API是否实现所决定的，然而这与上面同理，它们并不是。“尚未实现接口”和“没有那种资源”是两个层面的事情。下层并不是由上层的具体实现所决定。关键是它们是什么，它们本应该是什么样的。

这就好比不管有没有用web server，http协议就在那里。不管有没有web app，web server就在那里。

## 浏览器端的状态
如今浏览器端的Web App也越来越注重标准化的数据存储，换了个名字，叫状态。

这状态和服务端的数据库没有本质上的区别，和服务端的应用和磁盘中数据相比，中间夹了那么一层速率更糟糕的网络层。

如果没有糟糕的网络层，我们可能不需要浏览器端的存储层，甚至不需要API层，关系型数据库已经给你解决了事务问题，并且数据库层的开发者也已经被训练的非常好，他们很擅长怎么样做好范式化，直接操作数据库就好了。抽象上的差异直接在浏览器端负责反范式化的逻辑层解决就好了，就像服务端的服务层负责翻译持久层和应用的抽象一样。

但面对现实，共享远端的存储，基本不可能。因为随着存储量的增长，服务端的存储并不再是物理上单点的存储，而是多个节点，甚至它们之间也通过网络同步数据。

如果这样考虑，那就需要有个地方必须要能够解决分布式事务的问题，这不太可能是浏览器，因为处理分布式事务的单元必须是所有它的客户端均可见的，所以它一定在服务端。

再则，如果是分布式存储，那浏览器端的状态是整个应用状态的子集这件事情就更好理解了。

于是很关键的一点，就出现了。作为整个应用状态的一部分的浏览器端这个状态，是什么时刻被决定的？

到了浏览器端，如果也想从分层设计中受益，那这一点必须要非常认真地对待。首先要明白这个状态的设计，也不由它的使用层如何使用而决定，而也是业务的边界和概念模型。

首先要明确浏览器端状态，作为整个应用的状态的子集，它的边界在哪里？这个边界内业务的概念模型是什么样的？

如果你想保证这一层的稳定、不变，有一个技巧是去假设这个状态和它的操作层之间，也有一层非常缓慢的通信层，这个通信层比网络还糟糕。甚至这一层的设计者和使用层的设计着沟通效率也极低，比如一方在美国，一方在中国。这个时候你会怎么设计它呢？

## 设计思想的矛盾和尴尬
随着React的流行，函数式编程手段以很大的篇幅进入了我们的视野。而这种设计思路在某些点上，很微妙地与分层的设计思路发生冲突。
函数式编程是尽一切的可能把真正计算状态的时刻推迟，这思想本身是非常好的，仅从逻辑上它可能真的胜过面向对象那样随着执行时刻即刻修改状态为主的思想要好一些。
麻烦的是由于从应用的加载事件发生到真正的应用状态变更这一条路线上，我们要经过好多层速率不一样的介质。而每经过一个速率不一样的介质的时候都会涉及到Buffer, Cache及相应的事件处理机制。
浏览器端的状态事实上在整个应用中，是与Buffer, Cache处在等同的位置上。那它们应该与那一层更密切或者说更像哪一层的附属？

> 分层的原则是，当前层的所有东西，都是事先被确定下来的，不由使用（计算方式）的改变而改变。

Redux中state的reduce + compose的方式，很自然把“结构如何被确定”和“计算如何发生”放在了一起。

这也可以理解成：因为你要如何计算，所以某种东西应该如何被确定下来。

这与分层中“因为已被确定的事务是什么样的，我才要什么样的计算”的思路是有一些矛盾的。

这矛盾会进一步影响应用应该是如何被拆分，如何被组合。
