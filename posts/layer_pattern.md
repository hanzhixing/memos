# 如何在业务实现上把网络七层协议的思路一路扩展到屏幕上

这是一个前端工程师写的，主要给前端工程师看的，但是尽量没有使用前端领域专业术语写的，一篇技术随笔。

其实我要说的不是ISO7层协议，而是分层思想的本质。

我们需要一些概念上的共识。

## 我们说范式化的时候到底在说什么？。
狭义上，最直接最常见的引用这种定义的领域是关系型数据库。

数据库的范式化很复杂，很抽象，甚至为了精准的表达，有不少文献中都用到了数学公式。

范式化在关系型数据库这一语境中，其实通俗点讲是这样的——对于任何一种事物，尽一切的可能，非常努力地做到它只在一处被记录。对于它的属性，也做到只在一处记录。如果需要记录关联关系，那也尽一切的可能，非常努力地使用尽可能少的信息来记录。

为什么做这种事情呢？
因为在多处记录相同信息的时候，进行信息同步，保持它们之间的一致性实在是太困难了。同步，我们往往要把时间要素也考虑进去，“在什么时刻先更新哪一处？”是很要命的问题，因为你“先更新哪一处可能都是错的”。如果你不认同，那对不起，我错了，慢走不送。但请相信我，同步问题绝对是计算机科学中，最难解决的问题，它往往比我们能想象到的情况要复杂得多。你可能还没遇到让你的方案出丑的场景。

范式化对应的英语单词是normalize。
广义上，单从英文词汇字面含义上，它碰巧还可以表达正常化、标准化。

不就是设计字段吗？
扯这么多干嘛？
怎么还说我不正常了呢？

如果你脑中此时此刻飘过各种不适，别急。

数据库语境中的范式化虽然不是它的初衷，但以它特有的方式教育、训练着我们做一件事情。

减少信息量，有限、唯一、不变的方式管理这些信息。

## 那当我们说分层的时候到底在说什么？

网络7层协议，除非你是对硬件、驱动程序、操作系统内核进行特殊的编程，否则应该是不太会直接去操作机器码或汇编。

至少在Linux中，内核层面向程序员暴露的信息项是极少的。尽管也不算是屈指可数的量级，但和我们日常要处理的实际业务中的信息项的数量级相比，少的够可以了。Linux也是一路用一切皆文件的思想和口号让我们更容易理解它、学习它的工作方式。

信息量足够少，管理信息的手段有限、不变。

从硬件那一层，从底到上，一路走到内核这一层，至少是做到了这一点。所以到这儿，工业化程度已经是非常高的水平了。

应用层我们与内核打交道，可能会涉及到的信息项大致有这些。
- 文件描述符
- 文件类型
- 标准输入
- 标准输出
- 标准错误
- 以字节码描述的内容
- 内容的长度
- 打开
- 关闭
- 读取
- 写入
- 硬盘IO方式
- 描述文件中位置的指针

但是，更往上，越往上越惨不忍睹。

层出不穷的概念，定义不明确、模棱两可的概念一路膨胀到屏幕。

到屏幕这里，居然会有“面包屑、组合拳盒子”这种匪夷所思的词汇出现。甚至会看到魔兽世界、Dota、希腊神话等不同次元世界中的人物出现。
😱😰😭

没办法，这是现实，我们的世界正式如此的复杂。

这也暴露了计算机科学里边第二大难题“命名问题”。

## 从操作系统内核往上开始，我们需要一路同时解决两大难题——同步、命名。

标题既然是“如何”，如果你本来期待看到第一步做什么，第二步做什么，那非常抱歉，我只能很遗憾地告诉你，我也不知道。你在这一段往下也无法看到关于第一步第二步的内容。至少在操作层面，层分到这儿，还没有好懂的说明书可以看。

但是，如果想达到低层那种工业化水平和效率，我们最好能够理解我们面对什么样的问题，它们有多难，难在哪。涉及到层，我们需要非常刻意地，非常主动地去思考和交流。它们格外需要更多的精力和关注、绞尽脑汁的努力和艰辛的训练。

“网络七层协议，一切皆文件……”，它们历史上，也并不像现在那么明朗，也是通过类似艰辛的过程，一步一步变成今天这个样子的。你要明白古人为了区分“苹果”和“梨”，也是付出了心血的。有了“苹果”和“梨”，你以为已经能区分这两种水果了。但到果园转转，到水果店看看，那里有多少种不同的苹果，有多少种不同的梨。有的明明是个“小一点的西红柿”，但从某一天开始人们用了“圣女果”。你看到它们毕竟、真的就和西红柿不一样，所以你也认可了接受了。这时，你再看到那颗苹果，它还是苹果吗？叫“酸甜脆果”，“小仙果”为啥就不行吗？

所以，重点是我们想在当下语境中想要通过什么样的概括程度和区分度的概念来形成共识。

尽管范式化和分层，看上去是不一样的思路。但它们在更低层，是做一样的事情。

减少信息量，有限、唯一、不变的方式管理这些信息。

分层是一种以不变应万变的艺术，也是一层一层把抽象概念和粒度逼近真实世界的工业化的手段。

由于不同的层内，抽象的角度和粒度不一样导致的，跨层交互关系往往是交错的。但这并不是太大的问题。

你在应用程序中去访问文件系统，事实上也是如此的。你非常有可能在一个业务单元中去读取和写入不同的文件，反之一个文件也有可能被应用不同的单元读取和写入。只是它们都是文件，操作文件的方式是始终不变的。

再说一个非常核心的问题。

一个层内的事物是什么时刻被确定下来的？
这是最容易混淆的点。

层内的事物确定下来的时刻一定在我们定义它的边界之后，抽象这一层概念的粒度，以及行为方式的那个时间点。

这个时间点之后，这一层的内容，不会因为它的上一层的行为而发生质的改变。

很多人设计数据库的时候，以为数据表存在，是因为读取的程序希望如何如何读取，然后那个数据表才应该长成什么样。实际并不是。他们是一个产品的边界，一个业务的边界确定下来那个时刻，建立完概念模型的时间点被确定下来的。与程序怎么操作无关，与是否真的存在操作它们的程序无关，它们是因为产品和业务而形成的客观存在。如果业务确定要涵盖权限，那就不管上层是否真正实现了权限管理功能，权限相关的抽象和概念已经产生。这同时与是否真的在物理上给硬盘真正写入关于它的信息也无关。
在这个时间节点，我们可以选择物理上实现，或者不实现，这并不那么重要。但最好你要知道这个业务范畴已经有RBAC、ABAC这种经历多年实践检验的最佳实践的存在。以便避免你以上层的实现来推导的数据表没有能力做到“以不变应万变”，后续持续地影响着上层实现，一遍又一遍的改，每次改动都是“牵一发动全身”。

到web server这个分界，很多人也认为RESTful API中的资源，是由API是否实现所决定的，然而这与上面同理，它们并不是。“尚未实现接口”和“没有那种资源”是两个层面的事情。下层并不是由上层的具体实现所决定。关键是它们是什么，它们本应该是什么样的。

这就好比不管有没有用web server，http协议就在那里。不管有没有web app，web server就在那里。
